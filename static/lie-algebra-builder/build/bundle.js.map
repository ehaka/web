{"version":3,"file":"bundle.js","sources":["../../node_modules/svelte/internal/index.mjs","../../node_modules/svelte/store/index.mjs","../../node_modules/rational-arithmetic/lib/fast-factorize.js","../../node_modules/rational-arithmetic/lib/fast-intersect.js","../../node_modules/rational-arithmetic/lib/rational-number.js","../../node_modules/rational-arithmetic/src/main.js","../../node_modules/svelte/motion/index.mjs","../../src/data.js","../../src/centralextension.js","../../src/LieElement.svelte","../../src/utils.js","../../node_modules/copy-text-to-clipboard/index.js","../../src/Toolbar.svelte","../../src/Grid.svelte","../../src/main.js"],"sourcesContent":["function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction is_promise(value) {\n    return value && typeof value === 'object' && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value = ret) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction to_number(value) {\n    return value === '' ? undefined : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction claim_element(nodes, name, attributes, svg) {\n    for (let i = 0; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeName === name) {\n            let j = 0;\n            const remove = [];\n            while (j < node.attributes.length) {\n                const attribute = node.attributes[j++];\n                if (!attributes[attribute.name]) {\n                    remove.push(attribute.name);\n                }\n            }\n            for (let k = 0; k < remove.length; k++) {\n                node.removeAttribute(remove[k]);\n            }\n            return nodes.splice(i, 1)[0];\n        }\n    }\n    return svg ? svg_element(name) : element(name);\n}\nfunction claim_text(nodes, data) {\n    for (let i = 0; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 3) {\n            node.data = '' + data;\n            return nodes.splice(i, 1)[0];\n        }\n    }\n    return text(data);\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.wholeText !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    node.style.setProperty(key, value, important ? 'important' : '');\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    const z_index = (parseInt(computed_style.zIndex) || 0) - 1;\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', `display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ` +\n        `overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: ${z_index};`);\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = `data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>`;\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, false, false, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nclass HtmlTag {\n    constructor(anchor = null) {\n        this.a = anchor;\n        this.e = this.n = null;\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            this.e = element(target.nodeName);\n            this.t = target;\n            this.h(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\n\nconst active_docs = new Set();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = node.ownerDocument;\n    active_docs.add(doc);\n    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);\n    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});\n    if (!current_rules[name]) {\n        current_rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ``}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        active_docs.forEach(doc => {\n            const stylesheet = doc.__svelte_stylesheet;\n            let i = stylesheet.cssRules.length;\n            while (i--)\n                stylesheet.deleteRule(i);\n            doc.__svelte_rules = {};\n        });\n        active_docs.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error(`Function called outside component initialization`);\n    return current_component;\n}\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail);\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n        }\n    };\n}\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n}\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        callbacks.slice().forEach(fn => fn(event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\nlet flushing = false;\nconst seen_callbacks = new Set();\nfunction flush() {\n    if (flushing)\n        return;\n    flushing = true;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        for (let i = 0; i < dirty_components.length; i += 1) {\n            const component = dirty_components[i];\n            set_current_component(component);\n            update(component.$$);\n        }\n        dirty_components.length = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    flushing = false;\n    seen_callbacks.clear();\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config();\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config();\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    let config = fn(node, params);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = program.b - t;\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config();\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            info.blocks[i] = null;\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(child_ctx, dirty);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error(`Cannot have duplicate keys in a keyed each`);\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\n// source: https://html.spec.whatwg.org/multipage/indices.html\nconst boolean_attributes = new Set([\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n]);\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, classes_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (classes_to_add) {\n        if (attributes.class == null) {\n            attributes.class = classes_to_add;\n        }\n        else {\n            attributes.class += ' ' + classes_to_add;\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += \" \" + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += \" \" + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${String(value).replace(/\"/g, '&#34;').replace(/'/g, '&#39;')}\"`;\n        }\n    });\n    return str;\n}\nconst escaped = {\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\nfunction escape(html) {\n    return String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(parent_component ? parent_component.$$.context : []),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, options = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, options);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    return ` ${name}${value === true ? '' : `=${typeof value === 'string' ? JSON.stringify(escape(value)) : `\"${value}\"`}`}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : ``;\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor) {\n    const { fragment, on_mount, on_destroy, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    // onMount happens before the initial afterUpdate\n    add_render_callback(() => {\n        const new_on_destroy = on_mount.map(run).filter(is_function);\n        if (on_destroy) {\n            on_destroy.push(...new_on_destroy);\n        }\n        else {\n            // Edge case - component was destroyed immediately,\n            // most likely as a result of a binding initialising\n            run_all(new_on_destroy);\n        }\n        component.$$.on_mount = [];\n    });\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const prop_values = options.props || {};\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: null,\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(parent_component ? parent_component.$$.context : []),\n        // everything else\n        callbacks: blank_object(),\n        dirty\n    };\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, prop_values, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if ($$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor);\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set() {\n            // overridden by instance, if it has props\n        }\n    };\n}\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set() {\n        // overridden by instance, if it has props\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.24.0' }, detail)));\n}\nfunction append_dev(target, node) {\n    dispatch_dev(\"SvelteDOMInsert\", { target, node });\n    append(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev(\"SvelteDOMInsert\", { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev(\"SvelteDOMRemove\", { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? [\"capture\"] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    dispatch_dev(\"SvelteDOMAddEventListener\", { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev(\"SvelteDOMRemoveEventListener\", { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev(\"SvelteDOMRemoveAttribute\", { node, attribute });\n    else\n        dispatch_dev(\"SvelteDOMSetAttribute\", { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev(\"SvelteDOMSetProperty\", { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev(\"SvelteDOMSetDataset\", { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev(\"SvelteDOMSetData\", { node: text, data });\n    text.data = data;\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(`'target' is a required option`);\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn(`Component was already destroyed`); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error(`Infinite loop detected`);\n        }\n    };\n}\n\nexport { HtmlTag, SvelteComponent, SvelteComponentDev, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_transform, afterUpdate, append, append_dev, assign, attr, attr_dev, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_component, claim_element, claim_space, claim_text, clear_loops, component_subscribe, compute_rest_props, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, escape, escaped, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, getContext, get_binding_group_value, get_current_component, get_slot_changes, get_slot_context, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, has_prop, identity, init, insert, insert_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_function, is_promise, listen, listen_dev, loop, loop_guard, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_data, set_data_dev, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, spread, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, update_keyed_each, update_slot, validate_component, validate_each_argument, validate_each_keys, validate_slots, validate_store, xlink_attr };\n","import { noop, safe_not_equal, subscribe, run_all, is_function } from '../internal';\nexport { get_store_value as get } from '../internal';\n\nconst subscriber_queue = [];\n/**\n * Creates a `Readable` store that allows reading by subscription.\n * @param value initial value\n * @param {StartStopNotifier}start start and stop notifications for subscriptions\n */\nfunction readable(value, start) {\n    return {\n        subscribe: writable(value, start).subscribe,\n    };\n}\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n * @param {*=}value initial value\n * @param {StartStopNotifier=}start start and stop notifications for subscriptions\n */\nfunction writable(value, start = noop) {\n    let stop;\n    const subscribers = [];\n    function set(new_value) {\n        if (safe_not_equal(value, new_value)) {\n            value = new_value;\n            if (stop) { // store is ready\n                const run_queue = !subscriber_queue.length;\n                for (let i = 0; i < subscribers.length; i += 1) {\n                    const s = subscribers[i];\n                    s[1]();\n                    subscriber_queue.push(s, value);\n                }\n                if (run_queue) {\n                    for (let i = 0; i < subscriber_queue.length; i += 2) {\n                        subscriber_queue[i][0](subscriber_queue[i + 1]);\n                    }\n                    subscriber_queue.length = 0;\n                }\n            }\n        }\n    }\n    function update(fn) {\n        set(fn(value));\n    }\n    function subscribe(run, invalidate = noop) {\n        const subscriber = [run, invalidate];\n        subscribers.push(subscriber);\n        if (subscribers.length === 1) {\n            stop = start(set) || noop;\n        }\n        run(value);\n        return () => {\n            const index = subscribers.indexOf(subscriber);\n            if (index !== -1) {\n                subscribers.splice(index, 1);\n            }\n            if (subscribers.length === 0) {\n                stop();\n                stop = null;\n            }\n        };\n    }\n    return { set, update, subscribe };\n}\nfunction derived(stores, fn, initial_value) {\n    const single = !Array.isArray(stores);\n    const stores_array = single\n        ? [stores]\n        : stores;\n    const auto = fn.length < 2;\n    return readable(initial_value, (set) => {\n        let inited = false;\n        const values = [];\n        let pending = 0;\n        let cleanup = noop;\n        const sync = () => {\n            if (pending) {\n                return;\n            }\n            cleanup();\n            const result = fn(single ? values[0] : values, set);\n            if (auto) {\n                set(result);\n            }\n            else {\n                cleanup = is_function(result) ? result : noop;\n            }\n        };\n        const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {\n            values[i] = value;\n            pending &= ~(1 << i);\n            if (inited) {\n                sync();\n            }\n        }, () => {\n            pending |= (1 << i);\n        }));\n        inited = true;\n        sync();\n        return function stop() {\n            run_all(unsubscribers);\n            cleanup();\n        };\n    });\n}\n\nexport { derived, readable, writable };\n","function fastFactorize(n) {\n    const primeFactors = [];\n    const sqrt = ~~Math.sqrt(n);\n\n    let i = 2; // smallest prime\n    while (i <= sqrt && n != 1) {\n        if (n % i == 0) {\n            primeFactors.push(i);\n            n /= i;\n        } else {\n            i ++;\n        }\n    }\n\n    if (n != 1) {\n        primeFactors.push(n);\n    }\n\n    return primeFactors;\n}\n\nmodule.exports = fastFactorize;\n\n","function fastIntersect(a, b) {\n    // intersection of two SORTED lists, a and b\n\n    a = a.slice();\n    b = b.slice();\n    const intersection = [];\n\n    const shorter = a.length < b.length ? a : b;\n    const longer = a === shorter ? b : a;\n    const len = shorter.length;\n\n    for (const val of shorter) {\n        const pos = longer.indexOf(val);\n        if (pos > -1) {\n            intersection.push(val);\n            longer.splice(pos, 1);\n        }\n    }\n\n    return intersection;\n}\n\nmodule.exports = fastIntersect;\n\n","const fastFactorize = require('./fast-factorize.js');\nconst fastIntersect = require('./fast-intersect.js');\n\n// TODO: for 0/0 and Inf/Inf, implement NaN\n\nfunction getSign(val) {\n    if (val == 0) {\n        return 1;\n    } else if (val === Infinity) {\n        return 1;\n    } else if (val === -Infinity) {\n        return -1;\n    } else {\n        return val / Math.abs(val);\n    }\n}\n\nfunction floatToIntegerPair(n) {\n    const sign = getSign(n);\n    n = Math.abs(n);\n\n    let str = n.toString();\n    str = str.trim();\n\n    const split = str.split('.');\n    const integerPart = parseInt(split[0]);\n    const fractionPart = parseInt(split[1]);\n    const denominator = Math.pow(10, split[1].length);\n\n    return [\n        sign * (integerPart * denominator + fractionPart),\n        denominator\n    ];\n}\n\nclass Rational {\n\n    constructor(numerator, denominator = 1, sign = 1) {\n\n        // normalize signs before diving into complexity\n        const prod = numerator * denominator * getSign(sign);\n        if (prod == 0) {\n            if (numerator == 0) {\n                sign = getSign(denominator * getSign(sign));\n            } else {\n                sign = getSign(numerator * getSign(sign));\n            }\n        } else {\n            sign = getSign(prod);\n        }\n        numerator = Math.abs(numerator);\n        denominator = Math.abs(denominator);\n\n        // take care of infinities\n        //  - when numerator is Infinity:\n        //      - if denominator is Infinity, return NaN\n        //      - else, return Infinity\n        //  - when numerator is zero\n        //      - if denominator is zero, return NaN\n        //      - else, return zero\n        //  - when denominator is Infinity\n        //      - numerator must be nonzero finite, so return 0\n        //  - when denominator is zero\n        //      - numerator must be nonzero finite, so return Infinity\n        if (numerator === Infinity) {\n            if (denominator == Infinity) {\n                numerator = NaN;\n                denominator = NaN;\n            } else {\n                denominator = 1;\n            }\n        } else if (numerator == 0) {\n            if (denominator == 0) {\n                numerator = NaN;\n                denominator = NaN;\n            } else {\n                numerator = 0;\n                denominator = 1;\n            }\n        } else if (denominator === Infinity) {\n            numerator = 0;\n            denominator = 1;\n        } else if (denominator == 0) {\n            numerator = Infinity;\n            denominator = 1;\n        }\n\n        // take care of double floating points\n        const nIsFloat = numerator != ~~numerator && numerator !== Infinity && !isNaN(numerator);\n        const dIsFloat = denominator != ~~denominator && denominator !== Infinity && !isNaN(denominator);\n        if (nIsFloat || dIsFloat) {\n            const [nn, nd] = nIsFloat ? floatToIntegerPair(numerator) : [numerator, 1];\n            const [dn, dd] = dIsFloat ? floatToIntegerPair(denominator) : [denominator, 1];\n\n            const result = divide(\n                new Rational(nn, nd),\n                new Rational(dn, dd)\n            );\n            numerator = result.numerator;\n            denominator = result.denominator;\n        }\n\n        this.sign = sign;\n        this.numerator = numerator;\n        this.denominator = denominator;\n\n        this.normalize();\n    }\n\n    normalize() {\n        if (this._containsNaN()) {\n            this.sign = 1;\n            this.numerator = NaN;\n            this.denominator = NaN;\n        } else {\n            // normalize sign\n            const sign = this.valueOf() < 0 ? -1 : 1;\n            this.numerator = Math.abs(this.numerator);\n            this.denominator = Math.abs(this.denominator);\n\n            // reduce fraction\n            if (this.numerator == 0) {\n                this.denominator = 1;\n            } else {\n                const nFactors = fastFactorize(this.numerator);\n                const dFactors = fastFactorize(this.denominator);\n                const common = fastIntersect(nFactors, dFactors).reduce((acc, cur) => acc * cur, 1);\n\n                this.numerator /= common;\n                this.denominator /= common;\n            }\n        }\n        return this;\n    }\n\n    _containsNaN() {\n        return (isNaN(this.numerator) || isNaN(this.denominator));\n    }\n\n    valueOf() {\n        if (this._containsNaN()) {\n            return NaN;\n        } else {\n            return this.sign * this.numerator / this.denominator;\n        }\n    }\n\n    toString() {\n        if (this._containsNaN()) {\n            return `NaN`;\n        } else {\n            let str = '';\n            if (this.sign < 0) {\n                str += '-';\n            }\n            str += this.numerator;\n            if (this.denominator != 1) {\n                str += '/' + this.denominator;\n            }\n\n            return str;\n        }\n    }\n\n    equal(r) {\n        const a = this.normalize(),\n            b = r.normalize();\n\n        return (\n            a.sign == b.sign\n            && a.numerator == b.numerator\n            && a.denominator == b.denominator\n        );\n    }\n\n    clone() {\n        return new Rational(\n            this.numerator,\n            this.denominator,\n            this.sign,\n        );\n    }\n\n}\n\n// Unary operators\n\nfunction makeInstance(n) {\n    if (!(n instanceof Rational)) {\n        return new Rational(n);\n    } else {\n        return n;\n    }\n}\n\nfunction arith_invert(n) {\n    n = makeInstance(n);\n    return new Rational(n.numerator, n.denominator, -1 * n.sign);\n}\n\nfunction geom_invert(n) {\n    n = makeInstance(n);\n    return new Rational(n.denominator, n.numerator);\n}\n\nfunction abs(n) {\n    n = makeInstance(n);\n    if (n < 0) {\n        return arith_invert(n);\n    } else {\n        return n;\n    }\n}\n\n// Binary operators\n\nfunction add(a, b) {\n    a = makeInstance(a);\n    b = makeInstance(b);\n\n    const r = new Rational(\n        (a.numerator * a.sign * b.denominator) + (a.denominator * b.numerator * b.sign),\n        a.denominator * b.denominator\n    );\n    return r.normalize();\n}\n\nfunction subtract(a, b) {\n    return add(a, arith_invert(b));\n}\n\nfunction multiply(a, b) {\n    a = makeInstance(a);\n    b = makeInstance(b);\n\n    const r = new Rational(\n        a.numerator * b.numerator,\n        a.denominator * b.denominator,\n        a.sign * b.sign\n    );\n    return r.normalize();\n}\n\nfunction divide(a, b) {\n    return multiply(a, geom_invert(b));\n}\n\n\nmodule.exports = {\n    Rational,\n\n    abs,\n    add,\n    subtract,\n    multiply,\n    divide,\n};\n\n","const {\n    Rational,\n\n    abs,\n    add,\n    subtract,\n    multiply,\n    divide,\n} = require('../lib/rational-number.js');\n\nclass MalformedError extends Error {\n    constructor(value) {\n        super(`Malformed rational number string: ${value}`);\n    }\n}\n\nfunction parse(str) {\n    str = str.trim();\n\n    let sign = 1;\n    if (str.includes('-')) {\n        if (str[0] == '-') {\n            sign = -1;\n            str = str.substr(1).trim();\n        } else {\n            throw new MalformedError(str);\n        }\n    }\n\n    if (str.includes('/')) {\n        const split = str.split('/');\n        if (split.length > 2 || str.includes('.')) {\n            throw new MalformedError(str);\n        } else {\n            const numerator = parseInt(split[0]);\n            const denominator = parseInt(split[1]);\n            return new Rational(numerator, denominator, sign);\n        }\n    } else if (str.includes('.')){\n        const split = str.split('.');\n\n        if (split.length > 2 || str.includes('/')) {\n            throw new MalformedError(str);\n        } else {\n            const integerPart = parseInt(split[0]);\n            const fractionPart = parseInt(split[1]);\n            const denominator = Math.pow(10, split[1].length);\n\n            return new Rational(\n                integerPart * denominator + fractionPart,\n                denominator,\n                sign\n            );\n        }\n    } else {\n        return new Rational(parseInt(str), 1, sign);\n    }\n\n}\n\nfunction r(strings, ...args) {\n    args = args.map(a => a.toString()); // coerce in case any were Rationals\n    let str = strings[0];\n    for (let i = 0; i < args.length; i ++) {\n        str += args[i] + strings[i + 1];\n    }\n\n    return parse(str);\n}\n\nfunction addMany(...operands) {\n    return operands.reduce((acc, cur) => add(acc, cur), 0);\n}\n\nfunction mulMany(...operands) {\n    return operands.reduce((acc, cur) => multiply(acc, cur), 1);\n}\n\nmodule.exports = {\n    Rational,\n    r,\n\n    abs,\n    add: addMany,\n    sub: subtract,\n    mul: mulMany,\n    div: divide,\n}\n\n","import { writable } from '../store';\nimport { now, loop, assign } from '../internal';\nimport { linear } from '../easing';\n\nfunction is_date(obj) {\n    return Object.prototype.toString.call(obj) === '[object Date]';\n}\n\nfunction tick_spring(ctx, last_value, current_value, target_value) {\n    if (typeof current_value === 'number' || is_date(current_value)) {\n        // @ts-ignore\n        const delta = target_value - current_value;\n        // @ts-ignore\n        const velocity = (current_value - last_value) / (ctx.dt || 1 / 60); // guard div by 0\n        const spring = ctx.opts.stiffness * delta;\n        const damper = ctx.opts.damping * velocity;\n        const acceleration = (spring - damper) * ctx.inv_mass;\n        const d = (velocity + acceleration) * ctx.dt;\n        if (Math.abs(d) < ctx.opts.precision && Math.abs(delta) < ctx.opts.precision) {\n            return target_value; // settled\n        }\n        else {\n            ctx.settled = false; // signal loop to keep ticking\n            // @ts-ignore\n            return is_date(current_value) ?\n                new Date(current_value.getTime() + d) : current_value + d;\n        }\n    }\n    else if (Array.isArray(current_value)) {\n        // @ts-ignore\n        return current_value.map((_, i) => tick_spring(ctx, last_value[i], current_value[i], target_value[i]));\n    }\n    else if (typeof current_value === 'object') {\n        const next_value = {};\n        for (const k in current_value)\n            // @ts-ignore\n            next_value[k] = tick_spring(ctx, last_value[k], current_value[k], target_value[k]);\n        // @ts-ignore\n        return next_value;\n    }\n    else {\n        throw new Error(`Cannot spring ${typeof current_value} values`);\n    }\n}\nfunction spring(value, opts = {}) {\n    const store = writable(value);\n    const { stiffness = 0.15, damping = 0.8, precision = 0.01 } = opts;\n    let last_time;\n    let task;\n    let current_token;\n    let last_value = value;\n    let target_value = value;\n    let inv_mass = 1;\n    let inv_mass_recovery_rate = 0;\n    let cancel_task = false;\n    function set(new_value, opts = {}) {\n        target_value = new_value;\n        const token = current_token = {};\n        if (value == null || opts.hard || (spring.stiffness >= 1 && spring.damping >= 1)) {\n            cancel_task = true; // cancel any running animation\n            last_time = now();\n            last_value = new_value;\n            store.set(value = target_value);\n            return Promise.resolve();\n        }\n        else if (opts.soft) {\n            const rate = opts.soft === true ? .5 : +opts.soft;\n            inv_mass_recovery_rate = 1 / (rate * 60);\n            inv_mass = 0; // infinite mass, unaffected by spring forces\n        }\n        if (!task) {\n            last_time = now();\n            cancel_task = false;\n            task = loop(now => {\n                if (cancel_task) {\n                    cancel_task = false;\n                    task = null;\n                    return false;\n                }\n                inv_mass = Math.min(inv_mass + inv_mass_recovery_rate, 1);\n                const ctx = {\n                    inv_mass,\n                    opts: spring,\n                    settled: true,\n                    dt: (now - last_time) * 60 / 1000\n                };\n                const next_value = tick_spring(ctx, last_value, value, target_value);\n                last_time = now;\n                last_value = value;\n                store.set(value = next_value);\n                if (ctx.settled)\n                    task = null;\n                return !ctx.settled;\n            });\n        }\n        return new Promise(fulfil => {\n            task.promise.then(() => {\n                if (token === current_token)\n                    fulfil();\n            });\n        });\n    }\n    const spring = {\n        set,\n        update: (fn, opts) => set(fn(target_value, value), opts),\n        subscribe: store.subscribe,\n        stiffness,\n        damping,\n        precision\n    };\n    return spring;\n}\n\nfunction get_interpolator(a, b) {\n    if (a === b || a !== a)\n        return () => a;\n    const type = typeof a;\n    if (type !== typeof b || Array.isArray(a) !== Array.isArray(b)) {\n        throw new Error('Cannot interpolate values of different type');\n    }\n    if (Array.isArray(a)) {\n        const arr = b.map((bi, i) => {\n            return get_interpolator(a[i], bi);\n        });\n        return t => arr.map(fn => fn(t));\n    }\n    if (type === 'object') {\n        if (!a || !b)\n            throw new Error('Object cannot be null');\n        if (is_date(a) && is_date(b)) {\n            a = a.getTime();\n            b = b.getTime();\n            const delta = b - a;\n            return t => new Date(a + t * delta);\n        }\n        const keys = Object.keys(b);\n        const interpolators = {};\n        keys.forEach(key => {\n            interpolators[key] = get_interpolator(a[key], b[key]);\n        });\n        return t => {\n            const result = {};\n            keys.forEach(key => {\n                result[key] = interpolators[key](t);\n            });\n            return result;\n        };\n    }\n    if (type === 'number') {\n        const delta = b - a;\n        return t => a + t * delta;\n    }\n    throw new Error(`Cannot interpolate ${type} values`);\n}\nfunction tweened(value, defaults = {}) {\n    const store = writable(value);\n    let task;\n    let target_value = value;\n    function set(new_value, opts) {\n        if (value == null) {\n            store.set(value = new_value);\n            return Promise.resolve();\n        }\n        target_value = new_value;\n        let previous_task = task;\n        let started = false;\n        let { delay = 0, duration = 400, easing = linear, interpolate = get_interpolator } = assign(assign({}, defaults), opts);\n        if (duration === 0) {\n            if (previous_task) {\n                previous_task.abort();\n                previous_task = null;\n            }\n            store.set(value = target_value);\n            return Promise.resolve();\n        }\n        const start = now() + delay;\n        let fn;\n        task = loop(now => {\n            if (now < start)\n                return true;\n            if (!started) {\n                fn = interpolate(value, new_value);\n                if (typeof duration === 'function')\n                    duration = duration(value, new_value);\n                started = true;\n            }\n            if (previous_task) {\n                previous_task.abort();\n                previous_task = null;\n            }\n            const elapsed = now - start;\n            if (elapsed > duration) {\n                store.set(value = new_value);\n                return false;\n            }\n            // @ts-ignore\n            store.set(value = fn(easing(elapsed / duration)));\n            return true;\n        });\n        return task.promise;\n    }\n    return {\n        set,\n        update: (fn, opts) => set(fn(target_value, value), opts),\n        subscribe: store.subscribe\n    };\n}\n\nexport { spring, tweened };\n","import { derived, readable, writable } from 'svelte/store';\nimport { spring } from 'svelte/motion';\n\n// misc constants\nexport const githublink = \"https://github.com/ehaka/lie-algebra-builder\";\nexport const modes = [\n    \"nilpotent\",\n    \"graded\"\n];\n\n// layout data\nexport const gridsize = writable(70);\nexport const sqmin = readable(32);\nexport const showhelp = writable(false);\nexport const showexport = writable(false);\n\n// logic\nexport const selectedVector = writable(-1);\nexport const actualMove = readable(16);\n\nexport const disabled = writable({});\nexport const grid = writable({});\nexport const positions = writable({});\nexport const moveCallbacks = writable({});\nexport const mode = writable(modes[1]);\n\nexport const brackets = writable([]);\nexport let weights = [];\nexport const vecs = writable([]);\n\nexport const camera = spring(\n    { x: 0, y: 0 }, \n    {stiffness: 1, damping: 1}\n    );\n\n// undo/redo handling\nexport const historylabels = {\n    move: \"move\",\n    removevector: \"add vector\",\n    removebracket: \"central extension\",\n    addvector: \"add vector\",\n    addbracket: \"central extension\",\n    changemode: \"change mode\"\n};\nexport const redolist = writable([]);\nexport const undolist = writable([]);\nexport function addUndo(a) {\n    undolist.update(l => [...l, a]);\n    redolist.set([]);   \n}\n\n// derived data\nexport const buffer = derived(gridsize, $gridsize => $gridsize/6);\n\n// state save/load functions\nexport function resetAll() {\n    selectedVector.set(-1);\n    disabled.set({});\n    showexport.set(false);\n    showhelp.set(false);\n\n    grid.set({});\n    positions.set({});\n    moveCallbacks.set({});\n    \n    brackets.set([]);\n    vecs.set([]);\n    weights=[];\n    \n    camera.stiffness = 1;\n    camera.damping = 1;\n    camera.update($camera => ({x: 0,y: 0}));\n\n    redolist.set([]);\n    undolist.set([]);\n}","import { derived } from 'svelte/store';\nimport { Rational, sub, mul, div } from 'rational-arithmetic';\nimport { brackets, mode, weights } from './data.js';\nexport const extensions = derived([brackets, mode], centralExtensionBasis);\n\nfunction elimZero(matrix) {\n    // clear zero elements from rows of the matrix\n    for(let r in matrix) {\n        const row = matrix[r];\n        for(let c in row) {\n            if(isZero(row[c])) {\n                delete row[c];\n            }\n        }\n    }\n}\nfunction negateRational(r) {\n    return new Rational(r.numerator, r.denominator, -r.sign);\n}\nfunction isZero(r) {\n    return r.numerator == 0;\n}\n\nfunction divideRow(matrix, r, m) {\n    // divide elements of row r by m\n    const row = matrix[r];\n    for(let c in row) {\n        // rational-arithmetic division has a sign bug\n        const rc = row[c];\n        const d = div(rc,m);\n        const sgn = rc.sign*m.sign;\n        row[c] = new Rational(d.numerator, d.denominator, sgn);\n    }\n}\nfunction subsRowWithMult(matrix, r1, r2, m) {\n    // substract m*r1 from row r2\n    const row1  = matrix[r1];\n    const row2  = matrix[r2];\n    for(let c in row1) {\n        const val = mul(m,row1[c]);\n        if(c in row2) {\n            row2[c] = sub(row2[c], val);\n        }\n        else {\n            row2[c] = negateRational(val);\n        }\n    }\n}\n\nfunction rationalGaussianElim(matrix, numrows) {\n    // gaussian elimination for sparse matrix of\n    // rationals with arbitrary column labels\n    const pivotelems = {};\n    const pivotcols = [];\n    let r = 0;\n    while(r<numrows) {\n        const row = matrix[r];\n        // choose any nonzero element as a pivot\n        let pivot = null;\n        for(let c in row) {\n            const el = row[c];\n            if(isZero(el)) {\n                delete row[c];\n            }\n            else if(pivot===null) {\n                pivot = c;\n                pivotelems[r] = pivot;\n                pivotcols.push(pivot);\n\n                // normalize pivot element\n                divideRow(matrix, r, el);\n            }\n        }\n        if(pivot === null) {\n            // zero row, eliminate row from matrix\n            for(let r2=r; r2<numrows-1; r2++) {\n                matrix[r2] = matrix[r2+1];\n            }\n            delete matrix[numrows-1];\n                numrows--;\n            continue;\n        }\n\n        // clear pivot column from other rows\n        for(var r2=0;r2<numrows;r2++) {\n            if(r2==r) {\n                continue;\n            }\n\n            const row2 = matrix[r2];\n            if(pivot in row2) {\n                const val2 = row2[pivot];\n                subsRowWithMult(matrix, r, r2, val2);\n            }\n        }\n        r++;\n    }\n\n    return [pivotelems, pivotcols];\n}\n\nfunction computeKernel(matrix, numrows, cocycles) {\n    // apply gaussian elimination on matrix\n    const ret = rationalGaussianElim(matrix, numrows);\n    const [pivotelems, pivotcols] = ret;\n    // clear zeroes from sparse matrix\n    elimZero(matrix);\n\n    // compute a basis of the kernel\n    const kernel = [];\n    for(let i in cocycles) {\n        const pair = cocycles[i];\n        const pairstr = pair.toString();\n        if(pivotcols.indexOf(pairstr)>-1) {\n            continue;\n        }\n        // each non-pivot column [a,b] defines a basis element\n        // where the coefficient of [x,y] is the negation of the \n        // coefficient of [a,b] from the row with pivotcolumn [x,y]\n        const cocycle = {};\n        cocycle[pair] = new Rational(1, 1);\n        cocycle[[pair[1],pair[0]]] = new Rational(1, 1, -1);\n        for(let r in matrix) {\n            const row = matrix[r];\n            if(pairstr in row) {\n                const val = row[pair];\n                const piv = pivotelems[r];\n                const [x,y] = piv.split(\",\");\n                cocycle[piv] = negateRational(val);\n                cocycle[[y,x]] = val;\n            }\n        }\n        kernel.push(cocycle);\n    }\n\n    return kernel;\n}\n\nexport function centralExtensionBasis(params) {\n    const [brackets, mode] = params;\n    const len = brackets.length;\n\n    let matrix;\n    let numrows;\n    if(mode === \"nilpotent\"){\n        // store all cocycle constraints in one matrix\n        matrix = {};\n        numrows = 0;\n    }\n    else {\n        // in modes 'carnot' and 'graded', store cocycle \n        // constraints of different degrees separately\n        matrix = {};\n        numrows = {};\n    }\n    for(let i=0;i<len-2;i++) {\n        for(let j=i+1;j<len-1;j++) {\n            for(let k=j+1;k<len;k++) {\n                // add cocycle constraint from vectors i,j,k\n                // B([ij],k) + B([jk],i) + B([ki],j)=0\n                const row = {};\n\n                // columns for E_ab-E_ba, i<j<a<k=b\n                for(let a=j+1;a<k;a++) {\n                    const el = [i,j];\n                    if(el in brackets[a]) {\n                        row[[a,k]] = brackets[a][el];\n                    }\n                }\n\n                // columns for E_ab-E_ba, a=i,j,k < b\n                const cyclic = [[i,j,k],[j,k,i],[k,i,j]];\n                for(let h=0;h<3;h++) {\n                    const [x,y,z] = cyclic[h];\n                    for(let b=k+1;b<len;b++) {\n                        const el = [x,y];\n                        if(el in brackets[b]) {\n                            const val = brackets[b][el];\n                            row[[z,b]] = negateRational(val);\n                        }\n                    }    \n                }\n\n                if(Object.keys(row).length > 0) {\n                    if(mode===\"nilpotent\") {\n                        matrix[numrows] = row;\n                        numrows++;\n                    }\n                    else {\n                        // separate by degree of constraint\n                        const deg = weights[i]+weights[j]+weights[k];\n                        if(!(deg in matrix)) {\n                            matrix[deg] = {};\n                            numrows[deg] = 0;\n                        }\n                        matrix[deg][numrows[deg]] = row;\n                        numrows[deg]++;\n                    }\n                }\n            }\n        }\n    }\n\n    if(mode===\"nilpotent\") {\n        const cocycles = [];\n        for(let a=0;a<len-1;a++) {\n            for(let b=a+1;b<len;b++) {\n                cocycles.push([a,b]);\n            }\n        }\n        return computeKernel(matrix,numrows,cocycles);\n    }\n    // in graded modes the kernel is the direct sum of the homogeneous kernels\n    const cocycles = {};\n    for(let a=0;a<len-1;a++) {\n        for(let b=a+1;b<len;b++) {\n            const deg = weights[a]+weights[b];\n            if(!(deg in cocycles)) {\n                cocycles[deg] = [];\n            }\n            cocycles[deg].push([a,b]);\n        }\n    }\n    const totalkernel = [];\n    for(let deg in cocycles) {\n        const coc = cocycles[deg];\n        if(deg in matrix) {\n            const mat = matrix[deg];\n            const num = numrows[deg];\n            const ker = computeKernel(mat, num, coc);\n            totalkernel.push(...ker);\n        }\n        else {\n            // no constraints, kernel is full component\n            for(let i in coc) {\n                const pair = coc[i];\n                const cocycle = {}\n                cocycle[pair] = new Rational(1, 1);\n                cocycle[[pair[1],pair[0]]] = new Rational(1, 1, -1);\n                totalkernel.push(cocycle);\n            }\n        }\n    }\n    return totalkernel;\n    \n}\n\nexport function cannotBracket(cocyclebasis, i, j) {\n    // return true if there does not exist a 2-cocycle B with B(i,j) nonzero\n    const key = [i,j];\n    for(i in cocyclebasis) {\n        const B = cocyclebasis[i];\n        if(key in B) {\n            return false;\n        }\n    }\n    return true;\n}","<script>\n\timport { createEventDispatcher } from 'svelte';\n\timport { spring } from 'svelte/motion';\n\timport { derived } from 'svelte/store';\n\timport { cannotBracket, centralExtensionBasis, extensions } from './centralextension.js';\n\timport { brackets, buffer, camera, disabled, grid, gridsize, moveCallbacks, positions, selectedVector, addUndo, sqmin, actualMove, mode, weights, historylabels } from './data.js';\n\n\tlet x;\n\tlet y;\n\tlet moved;\n\t$: inmotion=moved>$actualMove;\n\tconst dispatch = createEventDispatcher();\n\texport let initx;\n\texport let inity;\n\texport let id;\n\texport let label;\n\tlet coords = spring({ x: initx*$gridsize, y: inity*$gridsize }, {stiffness: 1, damping: 1});\n\tlet prevpos = [initx,inity]; // last valid grid position\n\t$: $moveCallbacks[id] = gotoGridPos;\n\t$: gx = Math.round($coords.x/$gridsize);\n\t$: gy = $mode === \"nilpotent\" ? Math.round($coords.y/$gridsize) : prevpos[1];\n\t$: snapx = gx*$gridsize;\n\t$: snapy = gy*$gridsize;\n\t$: sqsize = Math.max($sqmin, $gridsize-2*$buffer);\n\t$: offset = -sqsize/2;\n\t$: $positions[id] = prevpos;\n\n\t// style helper variables\n\t$: selected = ($selectedVector == id);\n\t$: invalidbracket = cannotBracket($extensions, $selectedVector, id);\n\t$: nobracket = ($selectedVector>=0 && !selected && invalidbracket);\n\t$: $disabled[id] = nobracket;\n\n\tfunction gotoGridPos(gridx, gridy, soft) {\n\t\tif(soft) {\n\t\t\tcoords.stiffness = 0.3;\n\t\t\tcoords.damping = 0.7;\n\t\t}\n\t\telse {\n\t\t\tcoords.stiffness = coords.damping = 1;\n\t\t}\n\t\tdelete $grid[prevpos];\n\n\t\t$positions[id] = [gridx,gridy];\n\t\tweights[id] = gridy;\n\t\t$grid[[gridx,gridy]] = id;\n\t\tcoords.set({x: gridx*$gridsize, y:gridy*$gridsize});\n\t\tprevpos = [gridx, gridy];\n\t}\n\n\n\tfunction toggleSelect() {\n\t\tif($selectedVector == id) {\n\t\t\t$selectedVector = -1;\n\t\t}\n\t\telse {\n\t\t\t$selectedVector = id;\n\t\t}\n\t}\n\n\tfunction handleMousedown(event) {\n\t\tcoords.stiffness = coords.damping = 1;\n\t\tx = event.clientX;\n\t\ty = event.clientY;\n\t\tmoved = 0;\n\n\t\twindow.addEventListener('mousemove', handleMousemove);\n\t\twindow.addEventListener('mouseup', handleMouseup);\n\t}\n\tfunction handleMousemove(event) {\n\t\tconst dx = event.clientX - x;\n\t\tconst dy = event.clientY - y;\n\t\tif(!inmotion) {\n\t\t\tmoved+=Math.abs(dx);\n\t\t\tmoved+=Math.abs(dy);\n\t\t}\n\t\tx = event.clientX;\n\t\ty = event.clientY;\n\t\tcoords.update($coords => ({\n\t\t\tx: $coords.x + dx,\n\t\t\ty: $coords.y + dy\n\t\t}));\n\t}\n\tfunction handleMouseup(event) {\n\t\tx = event.clientX;\n\t\ty = event.clientY;\n\t\twindow.removeEventListener('mousemove', handleMousemove);\n\t\twindow.removeEventListener('mouseup', handleMouseup);\n\n\t\tif(!inmotion) {\n\t\t\tif($selectedVector>=0) {\n\t\t\t\tif(!invalidbracket) {\n\t\t\t\t\tdispatch(\"bracket\", {\n\t\t\t\t\t\tid1: $selectedVector, \n\t\t\t\t\t\tid2: id\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t$selectedVector = -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttoggleSelect();\n\t\t\t}\n\t\t}\n\t\tinmotion=false;\n\n\t\tconst pos = [gx, gy];\n        if(pos in $grid) {\n\t\t\tconst other = $grid[pos];\n            if(other == id) {\n                // object did not move\n\t\t\t\tgotoGridPos(gx,gy,true);\n                return;\n            }\n            // object dropped on top of a different object\n\t\t\tgotoGridPos(prevpos[0],prevpos[1],true);\n        }\n        else {\n            // object dropped in free location\n\n\t\t\t// add move back to undolist\n\t\t\tconst undo = {\n\t\t\t\ttype: historylabels.move,\n\t\t\t\tobj: id,\n\t\t\t\tx: prevpos[0],\n\t\t\t\ty: prevpos[1]\n\t\t\t};\n\t\t\tgotoGridPos(gx,gy,true);\n\t\t\taddUndo(undo);\n        }\n\t}\n</script>\n\n<style>\n\t.box {\n\t\tposition: absolute;\n\t\tborder-radius: 4px;\n\t\tborder-style: outset;\n\t\tborder-color: #000000;\n\t\tbackground-color: lightgray;\n        text-align: center;\n\t\tuser-select: none;\n\t\tleft: 0;\n\t}\n\t.ghost {\n\t\topacity: 0.2;\n\t}\n\t.selected {\n\t\tbackground-color: white;\n\t}\n\t.nobracket {\n\t\topacity: 0.4;\n\t}\n</style>\n\n{#if inmotion}\n<div class=\"box ghost\"\n\tstyle=\"width: {sqsize}px;\n\theight: {sqsize}px;\n\tleft: {offset}px;\n\ttop: {offset}px;\n\tline-height: {sqsize}px;\n\ttransform: translate({snapx+$camera.x}px,{snapy+$camera.y}px)\"\n></div>\n{/if}\n<div class=\"box\"\n\tclass:selected\n\tclass:nobracket\n\ton:mousedown={handleMousedown}\n\tstyle=\"width: {sqsize}px;\n\theight: {sqsize}px;\n\tleft: {offset}px;\n\ttop: {offset}px;\n\tline-height: {sqsize}px;\n\tcursor: {inmotion ? 'move' : 'auto'};\n\ttransform: translate({$coords.x+$camera.x}px,{$coords.y+$camera.y}px)\"\n>{label}</div>","import { tick } from \"svelte\";\n\nexport async function refreshMathjax() {\n    await tick();\n    MathJax.Hub.Queue([\"Typeset\",MathJax.Hub]);\n}","'use strict';\n\nconst copyTextToClipboard = (input, {target = document.body} = {}) => {\n\tconst element = document.createElement('textarea');\n\tconst previouslyFocusedElement = document.activeElement;\n\n\telement.value = input;\n\n\t// Prevent keyboard from showing on mobile\n\telement.setAttribute('readonly', '');\n\n\telement.style.contain = 'strict';\n\telement.style.position = 'absolute';\n\telement.style.left = '-9999px';\n\telement.style.fontSize = '12pt'; // Prevent zooming on iOS\n\n\tconst selection = document.getSelection();\n\tlet originalRange = false;\n\tif (selection.rangeCount > 0) {\n\t\toriginalRange = selection.getRangeAt(0);\n\t}\n\n\ttarget.append(element);\n\telement.select();\n\n\t// Explicit selection workaround for iOS\n\telement.selectionStart = 0;\n\telement.selectionEnd = input.length;\n\n\tlet isSuccess = false;\n\ttry {\n\t\tisSuccess = document.execCommand('copy');\n\t} catch (_) {}\n\n\telement.remove();\n\n\tif (originalRange) {\n\t\tselection.removeAllRanges();\n\t\tselection.addRange(originalRange);\n\t}\n\n\t// Get the focus back on the previously focused element, if any\n\tif (previouslyFocusedElement) {\n\t\tpreviouslyFocusedElement.focus();\n\t}\n\n\treturn isSuccess;\n};\n\nmodule.exports = copyTextToClipboard;\n// TODO: Remove this for the next major release\nmodule.exports.default = copyTextToClipboard;\n","<script>\n    import { writable } from 'svelte/store';\n    import { redolist, undolist, resetAll, brackets, grid, positions, vecs, modes, moveCallbacks, addUndo, selectedVector, showhelp, showexport, githublink, weights, mode, historylabels } from \"./data\";\n    import { refreshMathjax } from \"./utils.js\"\n    import { Rational, div } from 'rational-arithmetic';\n    import copyTextToClipboard from 'copy-text-to-clipboard';\n\n    let exportformat = \"text\";\n    let selectElement = {};\n    $: exportcontents = writeExportString(exportformat, $mode);\n\n    $: undotext = setUndoText(\"undo\",$undolist);\n    $: redotext = setUndoText(\"redo\",$redolist);\n    $: undodisabled = $undolist.length==0;\n    $: redodisabled = $redolist.length==0;\n\n    const undotool = {id: \"undo\", src: \"img/tools/undo.svg\", func: undo};\n    const redotool = {id: \"redo\", src: \"img/tools/redo.svg\", func: redo};\n    const othertools = [\n        {id: \"reset\", src: \"img/tools/cancel.svg\", func: reset},\n        {id: \"export\", src: \"img/tools/export.svg\", func: exportData},\n        {id: \"help\", src: \"img/tools/help.svg\", func: help},\n        {id: \"github\", src: \"img/tools/github.svg\", func: github},\n    ];\n\n    function mathjaxToPlainText(label) {\n        let out = label.replace(\"\\\\(\",\"\");\n        out = out.replace(\"\\\\)\",\"\");\n        out = out.replace(\"{\",\"\");\n        out = out.replace(\"}\",\"\");\n        return out;\n    }\n\n    function writeExportString(format, mode) {\n        const labels = [];\n        for(let i in $vecs) {\n            labels.push(mathjaxToPlainText($vecs[i].label));\n        }\n        if(labels.length == 0) {\n            return \"\";\n        }\n\n        let output = \"\";\n        const one = new Rational(1,1);\n        const negone = new Rational(1,1,-1);\n\n        if(format == \"text\") {\n            if(mode === \"graded\") {\n                const layers = {};\n                let anylayers = false;\n                for(let i in $positions) {\n                    const py = $positions[i][1];\n                    if(!(py in layers)) {\n                        layers[py] = [];\n                    }\n                    layers[py].push(labels[i]);\n                    anylayers=true;\n                }\n                if(anylayers) {\n                    output += \"Layers\\n\"\n                    const sortkey = (a, b) => parseInt(a) - parseInt(b);\n                    const sorted = Object.keys(layers).sort(sortkey);\n                    for(let i in sorted) {\n                        const py = sorted[i];\n                        output += py;\n                        output += \": \";\n                        output += layers[py].join(\",\");\n                        output += \"\\n\";\n                    }\n                    output += \"\\n\";\n                }\n            }\n\n            let anybrackets = false;\n            for(let i in $brackets) {\n                const cocycle = $brackets[i];\n                let row = \"\";\n                let brkt=false;\n                for(let pair in cocycle) {\n                    const [a,b] = pair.split(\",\");\n                    if(a<b) {\n                        brkt=true;\n                        const val = cocycle[pair];\n                        if(!val.equal(one)) {\n                            let multstr;\n                            if(val.equal(negone)) {\n                                multstr=\"-\"\n                            } else {\n                                multstr = val.denominator;\n                                if(val.numerator!=1) {\n                                    multstr += \"/\"+val.numerator;\n                                }\n                                multstr += \"*\";   \n                            }\n                            row += multstr;\n                        }\n                        row += \"[\";\n                        row += mathjaxToPlainText($vecs[a].label);\n                        row += \",\";\n                        row += mathjaxToPlainText($vecs[b].label);\n                        row +=\"] = \";\n                    }\n                }\n                if(brkt) {\n                    row += mathjaxToPlainText($vecs[i].label);\n                    //outputrows.push(row);\n                    if(!anybrackets) {\n                        anybrackets=true;\n                        output+=\"Brackets\\n\"\n                    }\n                    output+=row+\"\\n\";\n                }\n            }\n        }\n        else if(format == \"sage\") {\n            const commutators = {};\n            for(let i in $brackets) {\n                const cocycle = $brackets[i];\n                let row = \"\";\n                let brkt=false;\n                for(let pair in cocycle) {\n                    const val = cocycle[pair];\n                    const [a,b] = pair.split(\",\");\n                    if(a<b) {\n                        if(!(pair in commutators)) {\n                            commutators[pair] = {};\n                        }\n                        commutators[pair][i] = val;\n                    }\n                }\n            }\n            let noelems = true;\n            output = \"sc = {\";\n            for(let pair in commutators) {\n                if(noelems) {\n                    noelems = false;\n                    output += \"\\n\";\n                }\n                const [a,b] = pair.split(\",\");\n                output += \"    ('\";\n                output += labels[a];\n                output += \"','\";\n                output += labels[b];\n                output += \"') : {\";\n\n                const terms = commutators[pair];\n                const termstrs = [];\n                for(let k in terms) {\n                    const v = terms[k];\n                    let s = \"'\";\n                    s += labels[k];\n                    s += \"': \";\n                    if(v.sign<0) {\n                        s += \"-\";\n                    }\n                    s += v.numerator;\n                    if(v.denominator != 1) {\n                        s += \"/\";\n                        s += v.denominator;\n                    }\n                    termstrs.push(s);\n                }\n                output += termstrs.join(\",\");\n                output += \"},\\n\";\n            }\n\n            output += \"}\\n\";\n            //output += \"names = [\";\n            //output += labels.join(\",\");\n            //output += \"]\\n\";\n            //output += \"LieAlgebra(QQ, sc, names=names, nilpotent=True)\\n\";\n            output += \"L.<\";\n            output += labels.join(\",\");\n            output += \"> = \";\n            output += \"LieAlgebra(QQ, sc, nilpotent=True)\\n\";\n\n            if(mode === \"graded\") {\n                const layers = {};\n                let anylayers = false;\n                for(let i in $positions) {\n                    const py = $positions[i][1];\n                    if(!(py in layers)) {\n                        layers[py] = [];\n                    }\n                    layers[py].push(labels[i]);\n                    anylayers=true;\n                }\n                if(anylayers) {\n                    output += \"layers = {\\n\"\n                    const sortkey = (a, b) => parseInt(a) - parseInt(b);\n                    const sorted = Object.keys(layers).sort(sortkey);\n                    for(let i in sorted) {\n                        const py = sorted[i];\n                        output += \"    \";\n                        output += py;\n                        output += \": [\";\n                        output += layers[py].join(\",\");\n                        output += \"],\\n\";\n                    }\n                    output += \"}\\n\";\n                }\n            }\n        }\n        return output;\n    }\n\n    function copyExport() {\n        copyTextToClipboard(exportcontents);\n        const el = document.getElementById(\"exportbox\");\n        el.focus();\n        el.select();\n    }\n\n    function reversibleMove(move) {\n        const pos = $positions[move.obj];\n        const backmove = {\n            type: historylabels.move,\n            obj: move.obj,\n            x: pos[0],\n            y: pos[1]\n        };\n        $moveCallbacks[move.obj](move.x,move.y,false);\n        return backmove;\n    }\n\n    function setUndoText(base, undolist) {\n        const len = undolist.length;\n        if(len > 0) {\n            const action = undolist[len-1];\n            base += \" \";\n            base += action.type;\n        }\n        return base;\n    }\n\n    function undo() {\n        $showexport = false;\n        $showhelp = false;\n        const action = $undolist.pop();\n\n        let redoaction;\n        if(action.type === historylabels.removevector || action.type === historylabels.removebracket) {\n            if(action.type == historylabels.removevector) {\n                redoaction = {type: historylabels.addvector};\n            }\n            else {\n                redoaction = {type: historylabels.addbracket};\n            }\n\n            redoaction.vector = $vecs.pop();\n            redoaction.bracket = $brackets.pop();\n            redoaction.weight = weights.pop();\n            const id = $vecs.length;\n            const pos = $positions[id];\n            delete $positions[id];\n            delete $grid[pos];\n\n            //update dependencies\n            $vecs = $vecs;\n            $brackets = $brackets;\n            $positions = $positions;\n        } \n        else if(action.type === historylabels.move) {\n            redoaction = reversibleMove(action);\n        } \n        else if(action.type === historylabels.changemode) {\n            redoaction = {type: historylabels.changemode, mode: $mode};\n            $mode = action.mode;\n        }\n        $redolist.push(redoaction);\n\n        // update dependencies\n        $undolist = $undolist;\n        $redolist = $redolist;\n    }\n    function redo() {\n        $showexport = false;\n        $showhelp = false;\n        const action = $redolist.pop();\n\n        let undoaction;\n        if(action.type === historylabels.addbracket || action.type === historylabels.addvector) {\n            if(action.type === historylabels.addbracket) {\n                undoaction = {type: historylabels.removebracket};\n            }\n            else {\n                undoaction = {type: historylabels.removevector};\n            }\n\n            vecs.update(l => [...l, action.vector]);\n            brackets.update(l => [...l, action.bracket]);\n            weights.push(action.weight);\n            refreshMathjax();\n        }\n        else if(action.type === historylabels.move) {\n            undoaction = reversibleMove(action);\n        }\n        else if(action.type === historylabels.changemode) {\n            undoaction = {type: historylabels.changemode, mode: $mode};\n            $mode = action.mode;\n        }\n        $undolist.push(undoaction);\n\n        // update dependencies\n        $undolist = $undolist;\n        $redolist = $redolist;\n    }\n\n    function reset() {\n        resetAll();\n    }\n    function exportData() {\n        $showhelp=false;\n        $showexport = !$showexport;\n        if($showexport) {\n            exportcontents = writeExportString(exportformat, $mode);\n        }\n    }\n    function help() {\n        $showexport=false;\n        $showhelp = !$showhelp;\n    }\n    function github() {\n        window.open(githublink);\n    }\n    function confirmModeChange() {\n        if($brackets.length==0) {\n            $mode = selectElement.value;\n            return;\n        }\n        const nextmode = selectElement.value;\n        if($mode == nextmode) {\n            return;\n        }\n\n        // allow mode change only to less restrictive\n        if(modes.indexOf(nextmode)<modes.indexOf($mode)) {\n            const undo = {\n                type: historylabels.changemode,\n                mode: $mode\n            };\n            addUndo(undo);\n            $mode = nextmode;\n        }\n    }\n</script>\n<style>\n    .toolbar {\n        position: fixed;\n        display: flex;\n        gap: 0px;\n        padding: 4px;\n        padding-left: 16px;\n        padding-right: 16px;\n        left: 50%;\n        bottom: 32px;\n        transform: translate(-50%, 0px);\n\t\tborder-radius: 20px;\n        border-style: groove;\n\t\tborder-color: #000000;\n\t\tbackground-color: #d1d1d1;\n        z-index: 1000;\n    }\n    .toolbar .tooltipcontainer {\n        position: relative;\n    }\n    .tool {\n        position: relative;\n        width: 40px;\n        height: 40px;\n        background-position: center;\n        background-repeat: no-repeat;\n        background-size: cover;\n\t\tbackground-color: #d1d1d1;\n        border-style: solid;\n        border-color: #d1d1d1;\n    }\n    .tool:hover {\n        border-style: outset;\n        border-color: #ffffff;\n    }\n    .tool:active {\n        border-style: inset;\n        border-color: #ffffff;\n    }\n    .tool:disabled {\n        opacity: 0.3;\n\t\tbackground-color: #d1d1d1;\n        border-style: solid;\n        border-color: #d1d1d1;\n    }\n    .tool + .hint {\n        position: absolute;\n        left: 50%;\n        bottom: 0;\n        white-space: nowrap;\n        transform: translate(-50%, 28px);\n        visibility: hidden;\n        border-style: none;\n        background-color: #ffffff;\n    }\n    .tool:hover + .hint {\n        visibility: visible;\n    }\n    .exportdlg {\n        display: block;\n        position: absolute;\n        left: 50%;\n        top: 10%;\n        width: min(700px,80%);\n        height: 70%;\n        transform: translate(-50%, 0);\n\t\tborder-radius: 20px;\n        border-style: groove;\n\t\tborder-color: #000000;\n\t\tbackground-color: #e1e1e1;\n        padding: 8px;\n        z-index: 1001;\n        visibility: hidden;\n    }\n    .exportdlg .text {\n        position: absolute;\n        display: block;\n        left: 8px;\n        right: 12px;\n        top: 8px;\n        bottom: 48px;\n    }\n    .exportdlg .text textarea {\n        position: absolute;\n        width: 100%;\n        height: 100%;\n        border-style: solid;\n        border-width: 1px;\n\t\tborder-color: #000000;\n\t\tbackground-color: #ffffff;\n        resize: none;\n    }\n    .exportdlg .buttons {\n        position: absolute;\n        display:flex;\n        left: 8px;\n        right: 8px;\n        bottom: 8px;\n    }\n    .exportdlg .buttons .typebuttons {\n        display: inherit;\n        position: absolute;\n        gap: 16px;\n        right: 0;\n        bottom: 0;\n    }\n    .exportdlg .buttons .copy {\n        display: inherit;\n        position: absolute;\n        left: 0;\n        bottom: 0;\n    }\n    .helpdlg {\n        display: block;\n        position: absolute;\n        top: 10%;\n        width: min(550px,80%);\n        left: 50%;\n        max-height: 70%;\n        transform: translate(-50%, 0);\n\t\tborder-radius: 20px;\n        border-style: groove;\n\t\tborder-color: #000000;\n\t\tbackground-color: #f1f1f1;\n        padding: 8px;\n        z-index: 1001;\n        visibility: hidden;\n        overflow-y: auto;\n        margin: 8px;\n    }\n    .show {\n        visibility: visible;\n    }\n</style>\n\n<div class=\"toolbar\">\n    <select class=\"modeselect\" \n    bind:this={selectElement} \n    on:change={confirmModeChange}\n    value={$mode}>\n        {#each modes as modeopt,i}\n        <option disabled={$brackets.length>0 && i>modes.indexOf($mode)}>{modeopt}</option>\n        {/each}\n    </select>\n    <div class=\"tooltipcontainer\">\n        <button id={undotool.id} class=\"tool\" disabled={undodisabled} on:click={undotool.func}\n        style=\"background-image: url({undotool.src});\">\n        </button>\n        <span class=\"hint\">{undotext}</span>\n    </div>\n    <div class=\"tooltipcontainer\">\n        <button id={redotool.id} class=\"tool\" disabled={redodisabled} on:click={redotool.func}\n        style=\"background-image: url({redotool.src});\">\n        </button>\n        <span class=\"hint\">{redotext}</span>\n    </div>\n    {#each othertools as tool}\n    <div class=\"tooltipcontainer\">\n        <button id={tool.id} class=\"tool\" on:click={tool.func}\n        style=\"background-image: url({tool.src});\">\n        </button>\n        <span class=\"hint\">{tool.id}</span>\n    </div>\n    {/each}\n</div>\n<div class=\"exportdlg{$showexport ? \" show\" : \"\"}\">\n    <div class=\"text\">\n        <textarea id=\"exportbox\" bind:value={exportcontents}></textarea>\n    </div>\n    <div class=\"buttons\">\n        <div class=\"copy\">\n            <button on:click={copyExport}>Copy</button>\n        </div>\n        <div class=\"typebuttons\">\n            <button on:click={() => exportformat = \"text\"}>Text</button>\n            <button on:click={() => exportformat = \"sage\"}>Sage</button>\n        </div>\n    </div>\n</div>\n<div class=\"helpdlg{$showhelp ? \" show\" : \"\"}\">\n    <h1>Instructions</h1>\n    <p>Choose a Lie algebra type:</p>\n    <ul>\n        <li>nilpotent: no restrictions on central extensions</li>\n        <li>graded: the Lie algebra is graded over the integers</li>\n    </ul>\n    <p>Click on empty space to add an abelian factor.</p>\n    <p>Click a vector \\(X_i\\) to select it, then select another \n        vector \\(X_j\\) to define a central extension involving \n        the commutator \\([X_i,X_j]\\).</p>\n    <p>Drag vectors to move them.</p>\n    <p>Drag empty space to move the camera.</p>\n</div>","<script>\n    import { cannotBracket, centralExtensionBasis, extensions } from './centralextension.js'\n    import LieElement from \"./LieElement.svelte\";\n    import Toolbar from \"./Toolbar.svelte\";\n    import { refreshMathjax } from \"./utils.js\"\n    import { actualMove, brackets, camera, disabled, grid, gridsize, positions, selectedVector, vecs, addUndo, showexport, showhelp, weights, mode, historylabels }from './data.js';\n    import { onDestroy, onMount, tick } from \"svelte\";\n    \n    let x;\n    let y;\n\tlet moved;\n\t$: inmotion=moved>$actualMove;\n    $: rows = Math.ceil(window.innerHeight/$gridsize);\n    $: [firstlineh, startodd, firstrow] = firstLineHeight($camera.y);\n    $: lines = updateLines($positions, $camera, $gridsize);\n    $: displayrownumber = $mode != \"nilpotent\";\n\n    function updateLineCount(event) {\n        rows = Math.ceil(window.innerHeight/$gridsize);\n    }\n\n    function firstLineHeight(camy) {\n        const firstrow = Math.round(-camy/$gridsize);\n        camy = camy+$gridsize/2;\n        let h = camy % (2*$gridsize);\n        if(camy<0) {\n            h += 2*$gridsize;\n        }\n        if(h>$gridsize) {\n            return [h-$gridsize, true, firstrow];\n        }\n        return [h,false, firstrow];\n    }\n\n    async function updateLines(positions, camera, gridsize) {\n        await tick();\n        lines = [];\n\n        for(let i in $brackets) {\n            const cocycle = $brackets[i];\n            for(let pair in cocycle) {\n                // add a line a->i, where pair=a,b\n                const a = pair.split(\",\")[0];\n                const pos1 = positions[a];\n                const pos2 = positions[i];\n                const x1 = pos1[0]*gridsize+camera.x;\n                const x2 = pos2[0]*gridsize+camera.x;\n                const y1 = pos1[1]*gridsize+camera.y;\n                const y2 = pos2[1]*gridsize+camera.y;\n                const line = {x1, y1, x2, y2};\n                line.class = \"edge\";\n\n                // skip lines between incompatible when selected\n                if($disabled[a] || $disabled[i]) {\n                    line.class += \" disabled\";\n                }\n                lines.push(line);\n            }\n        }\n        return lines;\n    }\n\n    function addVector(gx, gy) {\n        // add an abelian factor\n        const nextid = $vecs.length;\n        const label = \"\\\\(X_{\" + (nextid+1) + \"}\\\\)\";\n        $vecs.push({label: label, initx: gx, inity: gy});\n        $vecs=$vecs; // assignment updates references\n        $grid[[gx,gy]] = nextid;\n        refreshMathjax();\n        $positions[nextid] = [gx,gy];\n        $brackets.push({});\n        weights.push(gy);\n        return nextid;\n    }\n\n    function emptyClick(x,y) {\n        if($showexport || $showhelp) {\n            $showexport=false;\n            $showhelp=false;\n            return;\n        }\n        const gx = Math.round(x/$gridsize);\n        const gy = Math.round(y/$gridsize);\n        const pos = [gx,gy];\n        if(pos in $grid) {\n            return;\n        }\n        addVector(gx,gy);\n\n        // add vector removal to undolist\n        const undo = {\n            type: historylabels.removevector\n        };\n        addUndo(undo);\n\n        $brackets = $brackets;\n    }\n\n    function createBracket(event) {\n        // find closest free spot below the drop position\n        const obj1 = event.detail.id1;\n        const obj2 = event.detail.id2;\n\n        // form list of all possible cocycles\n        const cocycles = [];\n        const pair=[obj1,obj2];\n        for(let i in $extensions) {\n            const cocycle = $extensions[i];\n            if(pair in cocycle) {\n                cocycles.push(cocycle);\n            }\n        }\n        // choose first possible cocycle\n        // TODO: present choices to the user somehow\n        const brkt = cocycles[0];\n\n        let gy;\n        if($mode === \"nilpotent\") {\n            // in nilpotent mode place elements just below the lowest\n            gy = weights[obj1];\n            for(let pair in brkt) {\n                const [a,b] = pair.split(\",\");\n                gy = Math.max(gy, weights[a], weights[b]);\n            }\n            gy++;\n        }\n        else {\n            // in graded mode the weight is the sum of weights\n            gy = weights[obj1]+weights[obj2];\n        }\n\n        // set x position halfway, or as close as possible\n        const halfway = ($positions[obj1][0]+$positions[obj2][0])/2;\n        let gx = Math.floor(halfway);\n        let jump = 0;\n        let sign = halfway>=gx ? -1 : 1;\n        while([gx,gy] in $grid) {\n            // alternate checking sides\n            sign = -sign;\n            jump++;\n            gx = gx+sign*jump;\n        }\n        const obj3 = addVector(gx,gy);\n\n        // add bracket relation between the elements\n        $brackets[obj3] = brkt;\n\n        // add vector removal to undolist\n        const undo = {\n            type: historylabels.removebracket\n        };\n        addUndo(undo);\n    }\n\n\tfunction handleMousedown(event) {\n        camera.stiffness = 1;\n        camera.damping = 1;\n\t\tx = event.clientX;\n        y = event.clientY;\n        moved=0;\n\n\t\twindow.addEventListener('mousemove', handleMousemove);\n\t\twindow.addEventListener('mouseup', handleMouseup);\n\t}\n\tfunction handleMousemove(event) {\n\t\tconst dx = event.clientX - x;\n\t\tconst dy = event.clientY - y;\n\t\tif(!inmotion) {\n\t\t\tmoved+=Math.abs(dx);\n\t\t\tmoved+=Math.abs(dy);\n\t\t}\n\t\tx = event.clientX;\n\t\ty = event.clientY;\n\t\tcamera.update($camera => ({\n\t\t\tx: $camera.x + dx,\n\t\t\ty: $camera.y + dy\n\t\t}));\n\t}\n\tfunction handleMouseup(event) {\n        if(!inmotion) {\n            emptyClick(event.clientX-$camera.x,event.clientY-$camera.y);\n        }\n        inmotion=false;\n\t\twindow.removeEventListener('mousemove', handleMousemove);\n        window.removeEventListener('mouseup', handleMouseup);\n    }\n    onMount(() => window.addEventListener('resize',updateLineCount));\n    onDestroy(() => window.removeEventListener('resize',updateLineCount));\n</script>\n\n<style>\n    .grid {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 100%;\n        overflow-y: hidden;\n    }\n    .nodrag {\n        -webkit-user-drag: none;\n        -khtml-user-drag: none;\n        -moz-user-drag: none;\n        -o-user-drag: none;\n    }\n    .background {\n        position: absolute;\n        display: block;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 100%;\n        user-select: none;\n    }\n    .bgstripe {\n        width: 100%;\n    }\n    .bgstripe:nth-child(odd) {\n        background-color: #f1f1f1;\n    }\n    .bgstripe:nth-child(even) {\n        background-color: #e8e8e8;\n    }\n    .edge {\n        stroke: black;\n        stroke-width: 2;\n    }\n    .disabled {\n        stroke-width: 2;\n        stroke-dasharray: 5 5;\n        opacity: 0.2;\n    }\n    .linecanvas {\n        position: absolute;\n        display: block;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 100%;\n    }\n    .label {\n        position: relative;\n        left: 0;\n        top: 0;\n        height: 0%;\n        line-height: 0px;\n        background-color: inherit;\n    }\n</style>\n\n<div class=\"grid\">\n    <div class=\"background nodrag\" \n    on:mousedown={handleMousedown}\n    style=\"cursor: {inmotion ? 'move' : 'auto'};\"\n    draggable=\"false\">\n        {#if startodd}\n            <div class=\"bgstripe\" \n            style=\"height: 0px;\" />\n            <div class=\"bgstripe\" \n            style=\"height: {firstlineh}px;\"></div>\n        {:else}\n            <div class=\"bgstripe\" \n            style=\"height: {firstlineh}px;\" ></div>\n        {/if}\n        {#each {length: rows} as _,i}\n            <div class=\"bgstripe\"\n            style=\"height: {$gridsize}px;\" >\n            {#if displayrownumber}\n                {firstrow+i+1}\n            {/if}\n            </div>\n        {/each}\n        {#await lines then drawlines}\n        <svg class=\"linecanvas\">\n            {#each drawlines as line}\n                <line {...line} />\n            {/each}\n        </svg>\n        {/await}\n    </div>\n    {#each $vecs as vec,i}\n        <LieElement id={i} {...vec}\n        on:bracket={createBracket} />\n    {/each}\n    <Toolbar />\n</div>  ","import App from './App.svelte';\n\nconst app = new App({\n\ttarget: document.body,\n\tprops: {}\n});\n\nexport default app;"],"names":["noop","assign","tar","src","k","run","fn","blank_object","Object","create","run_all","fns","forEach","is_function","thing","safe_not_equal","a","b","subscribe","store","callbacks","unsub","unsubscribe","component_subscribe","component","callback","$$","on_destroy","push","set_store_value","ret","value","set","is_client","window","now","performance","Date","raf","cb","requestAnimationFrame","tasks","Set","run_tasks","task","c","delete","f","size","append","target","node","appendChild","insert","anchor","insertBefore","detach","parentNode","removeChild","destroy_each","iterations","detaching","i","length","d","element","name","document","createElement","svg_element","createElementNS","text","data","createTextNode","space","listen","event","handler","options","addEventListener","removeEventListener","attr","attribute","removeAttribute","getAttribute","setAttribute","set_svg_attributes","attributes","key","set_data","wholeText","set_input_value","input","set_style","important","style","setProperty","select_option","select","option","__value","selected","toggle_class","toggle","classList","current_component","set_current_component","get_current_component","Error","createEventDispatcher","type","detail","e","createEvent","initCustomEvent","custom_event","slice","call","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","Promise","resolve","update_scheduled","schedule_update","then","flush","tick","add_render_callback","flushing","seen_callbacks","update","pop","has","add","clear","fragment","before_update","dirty","p","ctx","after_update","outroing","outros","group_outros","r","check_outros","transition_in","block","local","transition_out","o","handle_promise","promise","info","token","index","resolved","child_ctx","undefined","current","needs_flush","blocks","m","mount","error","catch","pending","get_spread_update","levels","updates","to_null_out","accounted_for","$$scope","n","create_component","mount_component","on_mount","new_on_destroy","map","filter","destroy_component","init","instance","create_fragment","not_equal","props","parent_component","prop_values","bound","context","Map","ready","rest","fill","make_dirty","hydrate","nodes","Array","from","childNodes","children","l","intro","SvelteComponent","[object Object]","this","$destroy","indexOf","splice","subscriber_queue","readable","start","writable","stop","subscribers","new_value","run_queue","s","invalidate","subscriber","derived","stores","initial_value","single","isArray","stores_array","auto","inited","values","cleanup","sync","result","unsubscribers","primeFactors","sqrt","Math","intersection","shorter","longer","val","pos","getSign","Infinity","abs","floatToIntegerPair","sign","str","toString","trim","split","integerPart","parseInt","fractionPart","denominator","pow","Rational","numerator","prod","NaN","nIsFloat","isNaN","dIsFloat","nn","nd","dn","dd","divide","normalize","_containsNaN","valueOf","nFactors","fastFactorize","dFactors","common","fastIntersect","reduce","acc","cur","makeInstance","arith_invert","multiply","subtract","require$$0","MalformedError","super","strings","args","includes","substr","parse","operands","sub","mul","div","is_date","obj","prototype","spring","opts","stiffness","damping","precision","last_time","current_token","last_value","target_value","inv_mass","inv_mass_recovery_rate","cancel_task","hard","soft","rate","fulfill","loop","min","settled","dt","next_value","tick_spring","current_value","delta","velocity","getTime","_","fulfil","modes","gridsize","sqmin","showhelp","showexport","selectedVector","actualMove","disabled","grid","positions","moveCallbacks","mode","brackets","weights","vecs","camera","x","y","historylabels","redolist","undolist","addUndo","buffer","$gridsize","extensions","params","len","matrix","numrows","j","row","el","cyclic","h","z","negateRational","keys","deg","cocycles","computeKernel","totalkernel","coc","mat","num","ker","pair","cocycle","isZero","divideRow","rc","sgn","subsRowWithMult","r1","r2","row1","row2","pivotelems","pivotcols","pivot","rationalGaussianElim","elimZero","kernel","pairstr","piv","moved","dispatch","initx","inity","id","label","coords","prevpos","gotoGridPos","gridx","gridy","$grid","$positions","handleMousemove","dx","clientX","dy","clientY","inmotion","$coords","handleMouseup","$selectedVector","invalidbracket","id1","id2","gx","gy","undo","$actualMove","$moveCallbacks","round","$mode","snapx","snapy","sqsize","max","$sqmin","$buffer","offset","cocyclebasis","cannotBracket","$extensions","nobracket","$disabled","async","refreshMathjax","MathJax","Hub","Queue","copyTextToClipboard","body","previouslyFocusedElement","activeElement","contain","position","left","fontSize","selection","getSelection","originalRange","rangeCount","getRangeAt","selectionStart","selectionEnd","isSuccess","execCommand","remove","removeAllRanges","addRange","focus","func","mathjaxToPlainText","out","replace","setUndoText","base","exportformat","selectElement","undotool","$showexport","$showhelp","action","$undolist","redoaction","vector","$vecs","bracket","$brackets","weight","reversibleMove","$redolist","redotool","undoaction","othertools","$camera","exportcontents","writeExportString","open","format","labels","output","one","negone","layers","anylayers","py","sortkey","sorted","sort","join","anybrackets","brkt","equal","multstr","commutators","noelems","terms","termstrs","v","move","backmove","undotext","redotext","undodisabled","redodisabled","getElementById","nextmode","spread_props","updateLineCount","rows","ceil","innerHeight","addVector","nextid","emptyClick","onDestroy","firstlineh","startodd","firstrow","camy","firstLineHeight","lines","pos1","pos2","x1","x2","line","y1","y2","class","updateLines","displayrownumber","obj1","obj2","halfway","floor","jump","obj3"],"mappings":"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"}