{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../../Grid.svelte",
    "../../LieElement.svelte",
    "../../Toolbar.svelte"
  ],
  "sourcesContent": [
    "<script>\n    import { cannotBracket, centralExtensionBasis, extensions } from './centralextension.js'\n    import LieElement from \"./LieElement.svelte\";\n    import Toolbar from \"./Toolbar.svelte\";\n    import { refreshMathjax } from \"./utils.js\"\n    import { actualMove, brackets, camera, disabled, grid, gridsize, positions, selectedVector, vecs, addUndo, showexport, showhelp, weights, mode, historylabels }from './data.js';\n    import { onDestroy, onMount, tick } from \"svelte\";\n    \n    let x;\n    let y;\n\tlet moved;\n\t$: inmotion=moved>$actualMove;\n    $: rows = Math.ceil(window.innerHeight/$gridsize);\n    $: [firstlineh, startodd, firstrow] = firstLineHeight($camera.y);\n    $: lines = updateLines($positions, $camera, $gridsize);\n    $: displayrownumber = $mode != \"nilpotent\";\n\n    function updateLineCount(event) {\n        rows = Math.ceil(window.innerHeight/$gridsize);\n    }\n\n    function firstLineHeight(camy) {\n        const firstrow = Math.round(-camy/$gridsize);\n        camy = camy+$gridsize/2;\n        let h = camy % (2*$gridsize);\n        if(camy<0) {\n            h += 2*$gridsize;\n        }\n        if(h>$gridsize) {\n            return [h-$gridsize, true, firstrow];\n        }\n        return [h,false, firstrow];\n    }\n\n    async function updateLines(positions, camera, gridsize) {\n        await tick();\n        lines = [];\n\n        for(let i in $brackets) {\n            const cocycle = $brackets[i];\n            for(let pair in cocycle) {\n                // add a line a->i, where pair=a,b\n                const a = pair.split(\",\")[0];\n                const pos1 = positions[a];\n                const pos2 = positions[i];\n                const x1 = pos1[0]*gridsize+camera.x;\n                const x2 = pos2[0]*gridsize+camera.x;\n                const y1 = pos1[1]*gridsize+camera.y;\n                const y2 = pos2[1]*gridsize+camera.y;\n                const line = {x1, y1, x2, y2};\n                line.class = \"edge\";\n\n                // skip lines between incompatible when selected\n                if($disabled[a] || $disabled[i]) {\n                    line.class += \" disabled\";\n                }\n                lines.push(line);\n            }\n        }\n        return lines;\n    }\n\n    function addVector(gx, gy) {\n        // add an abelian factor\n        const nextid = $vecs.length;\n        const label = \"\\\\(X_{\" + (nextid+1) + \"}\\\\)\";\n        $vecs.push({label: label, initx: gx, inity: gy});\n        $vecs=$vecs; // assignment updates references\n        $grid[[gx,gy]] = nextid;\n        refreshMathjax();\n        $positions[nextid] = [gx,gy];\n        $brackets.push({});\n        weights.push(gy);\n        return nextid;\n    }\n\n    function emptyClick(x,y) {\n        if($showexport ||Â $showhelp) {\n            $showexport=false;\n            $showhelp=false;\n            return;\n        }\n        const gx = Math.round(x/$gridsize);\n        const gy = Math.round(y/$gridsize);\n        const pos = [gx,gy];\n        if(pos in $grid) {\n            return;\n        }\n        addVector(gx,gy);\n\n        // add vector removal to undolist\n        const undo = {\n            type: historylabels.removevector\n        };\n        addUndo(undo);\n\n        $brackets = $brackets;\n    }\n\n    function createBracket(event) {\n        // find closest free spot below the drop position\n        const obj1 = event.detail.id1;\n        const obj2 = event.detail.id2;\n\n        // form list of all possible cocycles\n        const cocycles = [];\n        const pair=[obj1,obj2];\n        for(let i in $extensions) {\n            const cocycle = $extensions[i];\n            if(pair in cocycle) {\n                cocycles.push(cocycle);\n            }\n        }\n        // choose first possible cocycle\n        // TODO: present choices to the user somehow\n        const brkt = cocycles[0];\n\n        let gy;\n        if($mode === \"nilpotent\") {\n            // in nilpotent mode place elements just below the lowest\n            gy = weights[obj1];\n            for(let pair in brkt) {\n                const [a,b] = pair.split(\",\");\n                gy = Math.max(gy, weights[a], weights[b]);\n            }\n            gy++;\n        }\n        else {\n            // in graded mode the weight is the sum of weights\n            gy = weights[obj1]+weights[obj2];\n        }\n\n        // set x position halfway, or as close as possible\n        const halfway = ($positions[obj1][0]+$positions[obj2][0])/2;\n        let gx = Math.floor(halfway);\n        let jump = 0;\n        let sign = halfway>=gx ? -1 : 1;\n        while([gx,gy] in $grid) {\n            // alternate checking sides\n            sign = -sign;\n            jump++;\n            gx = gx+sign*jump;\n        }\n        const obj3 = addVector(gx,gy);\n\n        // add bracket relation between the elements\n        $brackets[obj3] = brkt;\n\n        // add vector removal to undolist\n        const undo = {\n            type: historylabels.removebracket\n        };\n        addUndo(undo);\n    }\n\n\tfunction handleMousedown(event) {\n        camera.stiffness = 1;\n        camera.damping = 1;\n\t\tx = event.clientX;\n        y = event.clientY;\n        moved=0;\n\n\t\twindow.addEventListener('mousemove', handleMousemove);\n\t\twindow.addEventListener('mouseup', handleMouseup);\n\t}\n\tfunction handleMousemove(event) {\n\t\tconst dx = event.clientX - x;\n\t\tconst dy = event.clientY - y;\n\t\tif(!inmotion) {\n\t\t\tmoved+=Math.abs(dx);\n\t\t\tmoved+=Math.abs(dy);\n\t\t}\n\t\tx = event.clientX;\n\t\ty = event.clientY;\n\t\tcamera.update($camera => ({\n\t\t\tx: $camera.x + dx,\n\t\t\ty: $camera.y + dy\n\t\t}));\n\t}\n\tfunction handleMouseup(event) {\n        if(!inmotion) {\n            emptyClick(event.clientX-$camera.x,event.clientY-$camera.y);\n        }\n        inmotion=false;\n\t\twindow.removeEventListener('mousemove', handleMousemove);\n        window.removeEventListener('mouseup', handleMouseup);\n    }\n    onMount(() => window.addEventListener('resize',updateLineCount));\n    onDestroy(() => window.removeEventListener('resize',updateLineCount));\n</script>\n\n<style>\n    .grid {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 100%;\n        overflow-y: hidden;\n    }\n    .nodrag {\n        -webkit-user-drag: none;\n        -khtml-user-drag: none;\n        -moz-user-drag: none;\n        -o-user-drag: none;\n    }\n    .background {\n        position: absolute;\n        display: block;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 100%;\n        user-select: none;\n    }\n    .bgstripe {\n        width: 100%;\n    }\n    .bgstripe:nth-child(odd) {\n        background-color: #f1f1f1;\n    }\n    .bgstripe:nth-child(even) {\n        background-color: #e8e8e8;\n    }\n    .edge {\n        stroke: black;\n        stroke-width: 2;\n    }\n    .disabled {\n        stroke-width: 2;\n        stroke-dasharray: 5 5;\n        opacity: 0.2;\n    }\n    .linecanvas {\n        position: absolute;\n        display: block;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 100%;\n    }\n    .label {\n        position: relative;\n        left: 0;\n        top: 0;\n        height: 0%;\n        line-height: 0px;\n        background-color: inherit;\n    }\n</style>\n\n<div class=\"grid\">\n    <div class=\"background nodrag\" \n    on:mousedown={handleMousedown}\n    style=\"cursor: {inmotion ? 'move' : 'auto'};\"\n    draggable=\"false\">\n        {#if startodd}\n            <div class=\"bgstripe\" \n            style=\"height: 0px;\" />\n            <div class=\"bgstripe\" \n            style=\"height: {firstlineh}px;\"></div>\n        {:else}\n            <div class=\"bgstripe\" \n            style=\"height: {firstlineh}px;\" ></div>\n        {/if}\n        {#each {length: rows} as _,i}\n            <div class=\"bgstripe\"\n            style=\"height: {$gridsize}px;\" >\n            {#if displayrownumber}\n                {firstrow+i+1}\n            {/if}\n            </div>\n        {/each}\n        {#await lines then drawlines}\n        <svg class=\"linecanvas\">\n            {#each drawlines as line}\n                <line {...line} />\n            {/each}\n        </svg>\n        {/await}\n    </div>\n    {#each $vecs as vec,i}\n        <LieElement id={i} {...vec}\n        on:bracket={createBracket} />\n    {/each}\n    <Toolbar />\n</div>  ",
    "<script>\n\timport { createEventDispatcher } from 'svelte';\n\timport { spring } from 'svelte/motion';\n\timport { derived } from 'svelte/store';\n\timport { cannotBracket, centralExtensionBasis, extensions } from './centralextension.js';\n\timport { brackets, buffer, camera, disabled, grid, gridsize, moveCallbacks, positions, selectedVector, addUndo, sqmin, actualMove, mode, weights, historylabels } from './data.js';\n\n\tlet x;\n\tlet y;\n\tlet moved;\n\t$: inmotion=moved>$actualMove;\n\tconst dispatch = createEventDispatcher();\n\texport let initx;\n\texport let inity;\n\texport let id;\n\texport let label;\n\tlet coords = spring({ x: initx*$gridsize, y: inity*$gridsize }, {stiffness: 1, damping: 1});\n\tlet prevpos = [initx,inity]; // last valid grid position\n\t$: $moveCallbacks[id] = gotoGridPos;\n\t$: gx = Math.round($coords.x/$gridsize);\n\t$: gy = $mode === \"nilpotent\" ? Math.round($coords.y/$gridsize) : prevpos[1];\n\t$: snapx = gx*$gridsize;\n\t$: snapy = gy*$gridsize;\n\t$: sqsize = Math.max($sqmin, $gridsize-2*$buffer);\n\t$: offset = -sqsize/2;\n\t$: $positions[id] = prevpos;\n\n\t// style helper variables\n\t$: selected = ($selectedVector == id);\n\t$: invalidbracket = cannotBracket($extensions, $selectedVector, id);\n\t$: nobracket = ($selectedVector>=0 && !selected && invalidbracket);\n\t$: $disabled[id] = nobracket;\n\n\tfunction gotoGridPos(gridx, gridy, soft) {\n\t\tif(soft) {\n\t\t\tcoords.stiffness = 0.3;\n\t\t\tcoords.damping = 0.7;\n\t\t}\n\t\telse {\n\t\t\tcoords.stiffness = coords.damping = 1;\n\t\t}\n\t\tdelete $grid[prevpos];\n\n\t\t$positions[id] = [gridx,gridy];\n\t\tweights[id] = gridy;\n\t\t$grid[[gridx,gridy]] = id;\n\t\tcoords.set({x: gridx*$gridsize, y:gridy*$gridsize});\n\t\tprevpos = [gridx, gridy];\n\t}\n\n\n\tfunction toggleSelect() {\n\t\tif($selectedVector == id) {\n\t\t\t$selectedVector = -1;\n\t\t}\n\t\telse {\n\t\t\t$selectedVector = id;\n\t\t}\n\t}\n\n\tfunction handleMousedown(event) {\n\t\tcoords.stiffness = coords.damping = 1;\n\t\tx = event.clientX;\n\t\ty = event.clientY;\n\t\tmoved = 0;\n\n\t\twindow.addEventListener('mousemove', handleMousemove);\n\t\twindow.addEventListener('mouseup', handleMouseup);\n\t}\n\tfunction handleMousemove(event) {\n\t\tconst dx = event.clientX - x;\n\t\tconst dy = event.clientY - y;\n\t\tif(!inmotion) {\n\t\t\tmoved+=Math.abs(dx);\n\t\t\tmoved+=Math.abs(dy);\n\t\t}\n\t\tx = event.clientX;\n\t\ty = event.clientY;\n\t\tcoords.update($coords => ({\n\t\t\tx: $coords.x + dx,\n\t\t\ty: $coords.y + dy\n\t\t}));\n\t}\n\tfunction handleMouseup(event) {\n\t\tx = event.clientX;\n\t\ty = event.clientY;\n\t\twindow.removeEventListener('mousemove', handleMousemove);\n\t\twindow.removeEventListener('mouseup', handleMouseup);\n\n\t\tif(!inmotion) {\n\t\t\tif($selectedVector>=0) {\n\t\t\t\tif(!invalidbracket) {\n\t\t\t\t\tdispatch(\"bracket\", {\n\t\t\t\t\t\tid1: $selectedVector, \n\t\t\t\t\t\tid2: id\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t$selectedVector = -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttoggleSelect();\n\t\t\t}\n\t\t}\n\t\tinmotion=false;\n\n\t\tconst pos = [gx, gy];\n        if(pos in $grid) {\n\t\t\tconst other = $grid[pos];\n            if(other == id) {\n                // object did not move\n\t\t\t\tgotoGridPos(gx,gy,true);\n                return;\n            }\n            // object dropped on top of a different object\n\t\t\tgotoGridPos(prevpos[0],prevpos[1],true);\n        }\n        else {\n            // object dropped in free location\n\n\t\t\t// add move back to undolist\n\t\t\tconst undo = {\n\t\t\t\ttype: historylabels.move,\n\t\t\t\tobj: id,\n\t\t\t\tx: prevpos[0],\n\t\t\t\ty: prevpos[1]\n\t\t\t};\n\t\t\tgotoGridPos(gx,gy,true);\n\t\t\taddUndo(undo);\n        }\n\t}\n</script>\n\n<style>\n\t.box {\n\t\tposition: absolute;\n\t\tborder-radius: 4px;\n\t\tborder-style: outset;\n\t\tborder-color: #000000;\n\t\tbackground-color: lightgray;\n        text-align: center;\n\t\tuser-select: none;\n\t\tleft: 0;\n\t}\n\t.ghost {\n\t\topacity: 0.2;\n\t}\n\t.selected {\n\t\tbackground-color: white;\n\t}\n\t.nobracket {\n\t\topacity: 0.4;\n\t}\n</style>\n\n{#if inmotion}\n<div class=\"box ghost\"\n\tstyle=\"width: {sqsize}px;\n\theight: {sqsize}px;\n\tleft: {offset}px;\n\ttop: {offset}px;\n\tline-height: {sqsize}px;\n\ttransform: translate({snapx+$camera.x}px,{snapy+$camera.y}px)\"\n></div>\n{/if}\n<div class=\"box\"\n\tclass:selected\n\tclass:nobracket\n\ton:mousedown={handleMousedown}\n\tstyle=\"width: {sqsize}px;\n\theight: {sqsize}px;\n\tleft: {offset}px;\n\ttop: {offset}px;\n\tline-height: {sqsize}px;\n\tcursor: {inmotion ? 'move' : 'auto'};\n\ttransform: translate({$coords.x+$camera.x}px,{$coords.y+$camera.y}px)\"\n>{label}</div>",
    "<script>\n    import { writable } from 'svelte/store';\n    import { redolist, undolist, resetAll, brackets, grid, positions, vecs, modes, moveCallbacks, addUndo, selectedVector, showhelp, showexport, githublink, weights, mode, historylabels } from \"./data\";\n    import { refreshMathjax } from \"./utils.js\"\n    import { Rational, div } from 'rational-arithmetic';\n    import copyTextToClipboard from 'copy-text-to-clipboard';\n\n    let exportformat = \"text\";\n    let selectElement = {};\n    $: exportcontents = writeExportString(exportformat, $mode);\n\n    $: undotext = setUndoText(\"undo\",$undolist);\n    $: redotext = setUndoText(\"redo\",$redolist);\n    $: undodisabled = $undolist.length==0;\n    $: redodisabled = $redolist.length==0;\n\n    const undotool = {id: \"undo\", src: \"img/tools/undo.svg\", func: undo};\n    const redotool = {id: \"redo\", src: \"img/tools/redo.svg\", func: redo};\n    const othertools = [\n        {id: \"reset\", src: \"img/tools/cancel.svg\", func: reset},\n        {id: \"export\", src: \"img/tools/export.svg\", func: exportData},\n        {id: \"help\", src: \"img/tools/help.svg\", func: help},\n        {id: \"github\", src: \"img/tools/github.svg\", func: github},\n    ];\n\n    function mathjaxToPlainText(label) {\n        let out = label.replace(\"\\\\(\",\"\");\n        out = out.replace(\"\\\\)\",\"\");\n        out = out.replace(\"{\",\"\");\n        out = out.replace(\"}\",\"\");\n        return out;\n    }\n\n    function writeExportString(format, mode) {\n        const labels = [];\n        for(let i in $vecs) {\n            labels.push(mathjaxToPlainText($vecs[i].label));\n        }\n        if(labels.length == 0) {\n            return \"\";\n        }\n\n        let output = \"\";\n        const one = new Rational(1,1);\n        const negone = new Rational(1,1,-1);\n\n        if(format == \"text\") {\n            if(mode === \"graded\") {\n                const layers = {};\n                let anylayers = false;\n                for(let i in $positions) {\n                    const py = $positions[i][1];\n                    if(!(py in layers)) {\n                        layers[py] = [];\n                    }\n                    layers[py].push(labels[i]);\n                    anylayers=true;\n                }\n                if(anylayers) {\n                    output += \"Layers\\n\"\n                    const sortkey = (a, b) => parseInt(a) - parseInt(b);\n                    const sorted = Object.keys(layers).sort(sortkey);\n                    for(let i in sorted) {\n                        const py = sorted[i];\n                        output += py;\n                        output += \": \";\n                        output += layers[py].join(\",\");\n                        output += \"\\n\";\n                    }\n                    output += \"\\n\";\n                }\n            }\n\n            let anybrackets = false;\n            for(let i in $brackets) {\n                const cocycle = $brackets[i];\n                let row = \"\";\n                let brkt=false;\n                for(let pair in cocycle) {\n                    const [a,b] = pair.split(\",\");\n                    if(a<b) {\n                        brkt=true;\n                        const val = cocycle[pair];\n                        if(!val.equal(one)) {\n                            let multstr;\n                            if(val.equal(negone)) {\n                                multstr=\"-\"\n                            } else {\n                                multstr = val.denominator;\n                                if(val.numerator!=1) {\n                                    multstr += \"/\"+val.numerator;\n                                }\n                                multstr += \"*\";   \n                            }\n                            row += multstr;\n                        }\n                        row += \"[\";\n                        row += mathjaxToPlainText($vecs[a].label);\n                        row += \",\";\n                        row += mathjaxToPlainText($vecs[b].label);\n                        row +=\"] = \";\n                    }\n                }\n                if(brkt) {\n                    row += mathjaxToPlainText($vecs[i].label);\n                    //outputrows.push(row);\n                    if(!anybrackets) {\n                        anybrackets=true;\n                        output+=\"Brackets\\n\"\n                    }\n                    output+=row+\"\\n\";\n                }\n            }\n        }\n        else if(format == \"sage\") {\n            const commutators = {};\n            for(let i in $brackets) {\n                const cocycle = $brackets[i];\n                let row = \"\";\n                let brkt=false;\n                for(let pair in cocycle) {\n                    const val = cocycle[pair];\n                    const [a,b] = pair.split(\",\");\n                    if(a<b) {\n                        if(!(pair in commutators)) {\n                            commutators[pair] = {};\n                        }\n                        commutators[pair][i] = val;\n                    }\n                }\n            }\n            let noelems = true;\n            output = \"sc = {\";\n            for(let pair in commutators) {\n                if(noelems) {\n                    noelems = false;\n                    output += \"\\n\";\n                }\n                const [a,b] = pair.split(\",\");\n                output += \"    ('\";\n                output += labels[a];\n                output += \"','\";\n                output += labels[b];\n                output += \"') : {\";\n\n                const terms = commutators[pair];\n                const termstrs = [];\n                for(let k in terms) {\n                    const v = terms[k];\n                    let s = \"'\";\n                    s += labels[k];\n                    s += \"': \";\n                    if(v.sign<0) {\n                        s += \"-\";\n                    }\n                    s += v.numerator;\n                    if(v.denominator != 1) {\n                        s += \"/\";\n                        s += v.denominator;\n                    }\n                    termstrs.push(s);\n                }\n                output += termstrs.join(\",\");\n                output += \"},\\n\";\n            }\n\n            output += \"}\\n\";\n            //output += \"names = [\";\n            //output += labels.join(\",\");\n            //output += \"]\\n\";\n            //output += \"LieAlgebra(QQ, sc, names=names, nilpotent=True)\\n\";\n            output += \"L.<\";\n            output += labels.join(\",\");\n            output += \"> = \";\n            output += \"LieAlgebra(QQ, sc, nilpotent=True)\\n\";\n\n            if(mode === \"graded\") {\n                const layers = {};\n                let anylayers = false;\n                for(let i in $positions) {\n                    const py = $positions[i][1];\n                    if(!(py in layers)) {\n                        layers[py] = [];\n                    }\n                    layers[py].push(labels[i]);\n                    anylayers=true;\n                }\n                if(anylayers) {\n                    output += \"layers = {\\n\"\n                    const sortkey = (a, b) => parseInt(a) - parseInt(b);\n                    const sorted = Object.keys(layers).sort(sortkey);\n                    for(let i in sorted) {\n                        const py = sorted[i];\n                        output += \"    \";\n                        output += py;\n                        output += \": [\";\n                        output += layers[py].join(\",\");\n                        output += \"],\\n\";\n                    }\n                    output += \"}\\n\";\n                }\n            }\n        }\n        return output;\n    }\n\n    function copyExport() {\n        copyTextToClipboard(exportcontents);\n        const el = document.getElementById(\"exportbox\");\n        el.focus();\n        el.select();\n    }\n\n    function reversibleMove(move) {\n        const pos = $positions[move.obj];\n        const backmove = {\n            type: historylabels.move,\n            obj: move.obj,\n            x: pos[0],\n            y: pos[1]\n        };\n        $moveCallbacks[move.obj](move.x,move.y,false);\n        return backmove;\n    }\n\n    function setUndoText(base, undolist) {\n        const len = undolist.length;\n        if(len > 0) {\n            const action = undolist[len-1];\n            base += \" \";\n            base += action.type;\n        }\n        return base;\n    }\n\n    function undo() {\n        $showexport = false;\n        $showhelp = false;\n        const action = $undolist.pop();\n\n        let redoaction;\n        if(action.type === historylabels.removevector || action.type === historylabels.removebracket) {\n            if(action.type == historylabels.removevector) {\n                redoaction = {type: historylabels.addvector};\n            }\n            else {\n                redoaction = {type: historylabels.addbracket};\n            }\n\n            redoaction.vector = $vecs.pop();\n            redoaction.bracket = $brackets.pop();\n            redoaction.weight = weights.pop();\n            const id = $vecs.length;\n            const pos = $positions[id];\n            delete $positions[id];\n            delete $grid[pos];\n\n            //update dependencies\n            $vecs = $vecs;\n            $brackets = $brackets;\n            $positions = $positions;\n        } \n        else if(action.type === historylabels.move) {\n            redoaction = reversibleMove(action);\n        } \n        else if(action.type === historylabels.changemode) {\n            redoaction = {type: historylabels.changemode, mode: $mode};\n            $mode = action.mode;\n        }\n        $redolist.push(redoaction);\n\n        // update dependencies\n        $undolist = $undolist;\n        $redolist = $redolist;\n    }\n    function redo() {\n        $showexport = false;\n        $showhelp = false;\n        const action = $redolist.pop();\n\n        let undoaction;\n        if(action.type === historylabels.addbracket || action.type === historylabels.addvector) {\n            if(action.type === historylabels.addbracket) {\n                undoaction = {type: historylabels.removebracket};\n            }\n            else {\n                undoaction = {type: historylabels.removevector};\n            }\n\n            vecs.update(l => [...l, action.vector]);\n            brackets.update(l => [...l, action.bracket]);\n            weights.push(action.weight);\n            refreshMathjax();\n        }\n        else if(action.type === historylabels.move) {\n            undoaction = reversibleMove(action);\n        }\n        else if(action.type === historylabels.changemode) {\n            undoaction = {type: historylabels.changemode, mode: $mode};\n            $mode = action.mode;\n        }\n        $undolist.push(undoaction);\n\n        // update dependencies\n        $undolist = $undolist;\n        $redolist = $redolist;\n    }\n\n    function reset() {\n        resetAll();\n    }\n    function exportData() {\n        $showhelp=false;\n        $showexport = !$showexport;\n        if($showexport) {\n            exportcontents = writeExportString(exportformat, $mode);\n        }\n    }\n    function help() {\n        $showexport=false;\n        $showhelp = !$showhelp;\n    }\n    function github() {\n        window.open(githublink);\n    }\n    function confirmModeChange() {\n        if($brackets.length==0) {\n            $mode = selectElement.value;\n            return;\n        }\n        const nextmode = selectElement.value;\n        if($mode == nextmode) {\n            return;\n        }\n\n        // allow mode change only to less restrictive\n        if(modes.indexOf(nextmode)<modes.indexOf($mode)) {\n            const undo = {\n                type: historylabels.changemode,\n                mode: $mode\n            };\n            addUndo(undo);\n            $mode = nextmode;\n        }\n    }\n</script>\n<style>\n    .toolbar {\n        position: fixed;\n        display: flex;\n        gap: 0px;\n        padding: 4px;\n        padding-left: 16px;\n        padding-right: 16px;\n        left: 50%;\n        bottom: 32px;\n        transform: translate(-50%, 0px);\n\t\tborder-radius: 20px;\n        border-style: groove;\n\t\tborder-color: #000000;\n\t\tbackground-color: #d1d1d1;\n        z-index: 1000;\n    }\n    .toolbar .tooltipcontainer {\n        position: relative;\n    }\n    .tool {\n        position: relative;\n        width: 40px;\n        height: 40px;\n        background-position: center;\n        background-repeat: no-repeat;\n        background-size: cover;\n\t\tbackground-color: #d1d1d1;\n        border-style: solid;\n        border-color: #d1d1d1;\n    }\n    .tool:hover {\n        border-style: outset;\n        border-color: #ffffff;\n    }\n    .tool:active {\n        border-style: inset;\n        border-color: #ffffff;\n    }\n    .tool:disabled {\n        opacity: 0.3;\n\t\tbackground-color: #d1d1d1;\n        border-style: solid;\n        border-color: #d1d1d1;\n    }\n    .tool + .hint {\n        position: absolute;\n        left: 50%;\n        bottom: 0;\n        white-space: nowrap;\n        transform: translate(-50%, 28px);\n        visibility: hidden;\n        border-style: none;\n        background-color: #ffffff;\n    }\n    .tool:hover + .hint {\n        visibility: visible;\n    }\n    .exportdlg {\n        display: block;\n        position: absolute;\n        left: 50%;\n        top: 10%;\n        width: min(700px,80%);\n        height: 70%;\n        transform: translate(-50%, 0);\n\t\tborder-radius: 20px;\n        border-style: groove;\n\t\tborder-color: #000000;\n\t\tbackground-color: #e1e1e1;\n        padding: 8px;\n        z-index: 1001;\n        visibility: hidden;\n    }\n    .exportdlg .text {\n        position: absolute;\n        display: block;\n        left: 8px;\n        right: 12px;\n        top: 8px;\n        bottom: 48px;\n    }\n    .exportdlg .text textarea {\n        position: absolute;\n        width: 100%;\n        height: 100%;\n        border-style: solid;\n        border-width: 1px;\n\t\tborder-color: #000000;\n\t\tbackground-color: #ffffff;\n        resize: none;\n    }\n    .exportdlg .buttons {\n        position: absolute;\n        display:flex;\n        left: 8px;\n        right: 8px;\n        bottom: 8px;\n    }\n    .exportdlg .buttons .typebuttons {\n        display: inherit;\n        position: absolute;\n        gap: 16px;\n        right: 0;\n        bottom: 0;\n    }\n    .exportdlg .buttons .copy {\n        display: inherit;\n        position: absolute;\n        left: 0;\n        bottom: 0;\n    }\n    .helpdlg {\n        display: block;\n        position: absolute;\n        top: 10%;\n        width: min(550px,80%);\n        left: 50%;\n        max-height: 70%;\n        transform: translate(-50%, 0);\n\t\tborder-radius: 20px;\n        border-style: groove;\n\t\tborder-color: #000000;\n\t\tbackground-color: #f1f1f1;\n        padding: 8px;\n        z-index: 1001;\n        visibility: hidden;\n        overflow-y: auto;\n        margin: 8px;\n    }\n    .show {\n        visibility: visible;\n    }\n</style>\n\n<div class=\"toolbar\">\n    <select class=\"modeselect\" \n    bind:this={selectElement} \n    on:change={confirmModeChange}\n    value={$mode}>\n        {#each modes as modeopt,i}\n        <option disabled={$brackets.length>0 && i>modes.indexOf($mode)}>{modeopt}</option>\n        {/each}\n    </select>\n    <div class=\"tooltipcontainer\">\n        <button id={undotool.id} class=\"tool\" disabled={undodisabled} on:click={undotool.func}\n        style=\"background-image: url({undotool.src});\">\n        </button>\n        <span class=\"hint\">{undotext}</span>\n    </div>\n    <div class=\"tooltipcontainer\">\n        <button id={redotool.id} class=\"tool\" disabled={redodisabled} on:click={redotool.func}\n        style=\"background-image: url({redotool.src});\">\n        </button>\n        <span class=\"hint\">{redotext}</span>\n    </div>\n    {#each othertools as tool}\n    <div class=\"tooltipcontainer\">\n        <button id={tool.id} class=\"tool\" on:click={tool.func}\n        style=\"background-image: url({tool.src});\">\n        </button>\n        <span class=\"hint\">{tool.id}</span>\n    </div>\n    {/each}\n</div>\n<div class=\"exportdlg{$showexport ? \" show\" : \"\"}\">\n    <div class=\"text\">\n        <textarea id=\"exportbox\" bind:value={exportcontents}></textarea>\n    </div>\n    <div class=\"buttons\">\n        <div class=\"copy\">\n            <button on:click={copyExport}>Copy</button>\n        </div>\n        <div class=\"typebuttons\">\n            <button on:click={() => exportformat = \"text\"}>Text</button>\n            <button on:click={() => exportformat = \"sage\"}>Sage</button>\n        </div>\n    </div>\n</div>\n<div class=\"helpdlg{$showhelp ? \" show\" : \"\"}\">\n    <h1>Instructions</h1>\n    <p>Choose a Lie algebra type:</p>\n    <ul>\n        <li>nilpotent: no restrictions on central extensions</li>\n        <li>graded: the Lie algebra is graded over the integers</li>\n    </ul>\n    <p>Click on empty space to add an abelian factor.</p>\n    <p>Click a vector \\(X_i\\) to select it, then select another \n        vector \\(X_j\\) to define a central extension involving \n        the commutator \\([X_i,X_j]\\).</p>\n    <p>Drag vectors to move them.</p>\n    <p>Drag empty space to move the camera.</p>\n</div>"
  ],
  "names": [],
  "mappings": "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"
}