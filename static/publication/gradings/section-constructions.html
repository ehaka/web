<!DOCTYPE html>
<!--**************************************-->
<!--*    Generated from PreTeXt source   *-->
<!--*    on 2020-11-13T12:10:22+01:00    *-->
<!--*                                    *-->
<!--*      https://pretextbook.org       *-->
<!--*                                    *-->
<!--**************************************-->
<html lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Constructions</title>
<meta name="Keywords" content="Authored in PreTeXt">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [['\\(','\\)']]
    },
    asciimath2jax: {
        ignoreClass: ".*",
        processClass: "has_am"
    },
    jax: ["input/AsciiMath"],
    extensions: ["asciimath2jax.js"],
    TeX: {
        extensions: ["extpfeil.js", "autobold.js", "https://pretextbook.org/js/lib/mathjaxknowl.js", "AMScd.js", ],
        // scrolling to fragment identifiers is controlled by other Javascript
        positionToHash: false,
        equationNumbers: { autoNumber: "none", useLabelIds: true, },
        TagSide: "right",
        TagIndent: ".8em",
    },
    // HTML-CSS output Jax to be dropped for MathJax 3.0
    "HTML-CSS": {
        scale: 88,
        mtextFontInherit: true,
    },
    CommonHTML: {
        scale: 88,
        mtextFontInherit: true,
    },
});
</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_CHTML-full"></script><script src="https://pretextbook.org/js/lib/jquery.min.js"></script><script src="https://pretextbook.org/js/lib/jquery.sticky.js"></script><script src="https://pretextbook.org/js/lib/jquery.espy.min.js"></script><script src="https://pretextbook.org/js/0.13/pretext.js"></script><script src="https://pretextbook.org/js/0.13/pretext_add_on.js"></script><script src="https://pretextbook.org/js/lib/knowl.js"></script><link href="https://fonts.googleapis.com/css?family=Open+Sans:400,400italic,600,600italic" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=Inconsolata:400,700&amp;subset=latin,latin-ext" rel="stylesheet" type="text/css">
<link href="https://pretextbook.org/css/0.31/pretext.css" rel="stylesheet" type="text/css">
<link href="https://pretextbook.org/css/0.31/pretext_add_on.css" rel="stylesheet" type="text/css">
<link href="https://pretextbook.org/css/0.31/banner_default.css" rel="stylesheet" type="text/css">
<link href="https://pretextbook.org/css/0.31/toc_default.css" rel="stylesheet" type="text/css">
<link href="https://pretextbook.org/css/0.31/knowls_default.css" rel="stylesheet" type="text/css">
<link href="https://pretextbook.org/css/0.31/style_default.css" rel="stylesheet" type="text/css">
<link href="https://pretextbook.org/css/0.31/colors_default.css" rel="stylesheet" type="text/css">
<link href="https://pretextbook.org/css/0.31/setcolors.css" rel="stylesheet" type="text/css">
<!-- 2019-10-12: Temporary - CSS file for experiments with styling --><link href="developer.css" rel="stylesheet" type="text/css">
</head>
<body id="gradings" class="mathbook-article has-toc has-sidebar-left">
<a class="assistive" href="#content">Skip to main content</a><div class="hidden-content" style="display:none">\(\newcommand{\abs}[1]{\left\lvert#1\right\rvert}
\newcommand{\restr}[2]{\left.#1\right\vert_{#2}}
\newcommand{\der}{\operatorname{der}}
\newcommand{\Aut}{\operatorname{Aut}}
\newcommand{\ad}{\operatorname{ad}}
\newcommand{\Ad}{\operatorname{Ad}}
\newcommand{\positiveset}{\mathbf{A}_+}
\newcommand{\lt}{&lt;}
\newcommand{\gt}{&gt;}
\newcommand{\amp}{&amp;}
\)</div>
<header id="masthead" class="smallbuttons"><div class="banner"><div class="container">
<a id="logo-link" href=""></a><div class="title-container">
<h1 class="heading"><a href="gradings.html"><span class="title">Gradings for nilpotent Lie algebras</span></a></h1>
<p class="byline">Eero Hakavuori, Ville Kivioja, Terhi Moisala, Francesca Tripaldi</p>
</div>
</div></div>
<nav id="primary-navbar" class="navbar"><div class="container">
<div class="navbar-top-buttons">
<button class="sidebar-left-toggle-button button active" aria-label="Show or hide table of contents sidebar">Contents</button><div class="tree-nav toolbar toolbar-divisor-3"><span class="threebuttons"><a id="previousbutton" class="previous-button toolbar-item button" href="section-gradings.html" title="Previous">Prev</a><a id="upbutton" class="up-button button toolbar-item" href="gradings.html" title="Up">Up</a><a id="nextbutton" class="next-button button toolbar-item" href="section-applications.html" title="Next">Next</a></span></div>
</div>
<div class="navbar-bottom-buttons toolbar toolbar-divisor-4">
<button class="sidebar-left-toggle-button button toolbar-item active">Contents</button><a class="previous-button toolbar-item button" href="section-gradings.html" title="Previous">Prev</a><a class="up-button button toolbar-item" href="gradings.html" title="Up">Up</a><a class="next-button button toolbar-item" href="section-applications.html" title="Next">Next</a>
</div>
</div></nav></header><div class="page">
<div id="sidebar-left" class="sidebar" role="navigation"><div class="sidebar-content">
<nav id="toc"><ul>
<li class="link frontmatter">
<a href="frontmatter-1.html" data-scroll="frontmatter-1"><span class="title">Front Matter</span></a><ul><li><a href="acknowledgement-1.html" data-scroll="acknowledgement-1">Acknowledgements</a></li></ul>
</li>
<li class="link">
<a href="section-introduction.html" data-scroll="section-introduction"><span class="codenumber">1</span> <span class="title">Introduction</span></a><ul>
<li><a href="section-introduction.html#subsection-1" data-scroll="subsection-1">Overview</a></li>
<li><a href="section-introduction.html#subsection-2" data-scroll="subsection-2">Main results</a></li>
<li><a href="section-introduction.html#subsection-3" data-scroll="subsection-3">Structure of the paper</a></li>
</ul>
</li>
<li class="link">
<a href="section-gradings.html" data-scroll="section-gradings"><span class="codenumber">2</span> <span class="title">Gradings</span></a><ul>
<li><a href="section-gradings.html#ssec-gradings-and-equivalences" data-scroll="ssec-gradings-and-equivalences">Gradings and equivalences</a></li>
<li><a href="section-gradings.html#ssec-univ-gradings" data-scroll="ssec-univ-gradings">Universal gradings</a></li>
<li><a href="section-gradings.html#sec-gradings-by-tori" data-scroll="sec-gradings-by-tori">Gradings induced by tori</a></li>
<li><a href="section-gradings.html#section-maximal-gradings" data-scroll="section-maximal-gradings">Maximal gradings</a></li>
<li><a href="section-gradings.html#subsection-torsion-free" data-scroll="subsection-torsion-free">Enumeration of torsion-free gradings</a></li>
</ul>
</li>
<li class="link active">
<a href="section-constructions.html" data-scroll="section-constructions"><span class="codenumber">3</span> <span class="title">Constructions</span></a><ul>
<li><a href="section-constructions.html#section-stratifications" data-scroll="section-stratifications">Stratifications</a></li>
<li><a href="section-constructions.html#sssec-pos-gradings" data-scroll="sssec-pos-gradings">Positive gradings</a></li>
<li><a href="section-constructions.html#section-maximal-construction" data-scroll="section-maximal-construction">Maximal gradings</a></li>
</ul>
</li>
<li class="link">
<a href="section-applications.html" data-scroll="section-applications"><span class="codenumber">4</span> <span class="title">Applications</span></a><ul>
<li><a href="section-applications.html#applications-structure" data-scroll="applications-structure">Structure from maximal gradings</a></li>
<li><a href="section-applications.html#applications-classification" data-scroll="applications-classification">Classification of gradings in low dimension</a></li>
<li><a href="section-applications.html#applications-heintze" data-scroll="applications-heintze">Enumerating Heintze groups</a></li>
<li><a href="section-applications.html#applications-lpq" data-scroll="applications-lpq">Bounds for non-vanishing \(\ell^{q,p}\) cohomology</a></li>
</ul>
</li>
<li class="link backmatter"><a href="backmatter-1.html" data-scroll="backmatter-1"><span class="title">Back Matter</span></a></li>
<li class="link"><a href="section-positive-gradings.html" data-scroll="section-positive-gradings"><span class="codenumber">A</span> <span class="title">Existence of a positive realization</span></a></li>
<li class="link">
<a href="appendix-classification.html" data-scroll="appendix-classification"><span class="codenumber">B</span> <span class="title">Complete classification in low dimension</span></a><ul>
<li><a href="appendix-classification.html#classification-overview" data-scroll="classification-overview">Overview</a></li>
<li><a href="classification-dim2.html">Dimension 2</a></li>
<li><a href="classification-dim3.html">Dimension 3</a></li>
<li><a href="classification-dim4.html">Dimension 4</a></li>
<li><a href="classification-dim5.html">Dimension 5</a></li>
<li><a href="classification-dim6.html">Dimension 6</a></li>
<li><a href="classification-dim7.html">Dimension 7</a></li>
</ul>
</li>
<li class="link"><a href="appendix-3.html" data-scroll="appendix-3"><span class="codenumber">C</span> <span class="title">Notation</span></a></li>
<li class="link"><a href="section-references.html" data-scroll="section-references"><span class="title">References</span></a></li>
</ul></nav><div class="extras"><nav><a class="mathbook-link" href="https://pretextbook.org">Authored in PreTeXt</a><a href="https://www.mathjax.org"><img title="Powered by MathJax" src="https://www.mathjax.org/badge/badge.gif" alt="Powered by MathJax"></a></nav></div>
</div></div>
<main class="main"><div id="content" class="pretext-content"><section class="section" id="section-constructions"><h2 class="heading hide-type">
<span class="type">Section</span> <span class="codenumber">3</span> <span class="title">Constructions</span>
</h2>
<section class="subsection" id="section-stratifications"><h3 class="heading hide-type">
<span class="type">Subsection</span> <span class="codenumber">3.1</span> <span class="title">Stratifications</span>
</h3>
<article class="definition definition-like" id="def-stratification"><h6 class="heading">
<span class="type">Definition</span><span class="space"> </span><span class="codenumber">3.1</span><span class="period">.</span>
</h6>
<p id="p-91">A <dfn class="terminology">stratification</dfn> (a.k.a. <dfn class="terminology">Carnot grading</dfn>) is a <a class="xref" data-knowl="./knowl/def-grading.html" title="Definition 2.1">\(\mathbb{Z}\)-grading</a> \(\mathfrak{g}=\bigoplus_{n\in\mathbb{Z}}V_n\) such that \(V_1\) generates \(\mathfrak{g}\) as a Lie algebra. A Lie algebra \(\mathfrak{g}\) is <dfn class="terminology">stratifiable</dfn> if it admits a stratification.</p></article><p id="p-92">In this section we show that constructing a stratification for a Lie algebra (or determining that one does not exist) is a linear problem and, consequently, prove <a class="xref" data-knowl="./knowl/theorem-stratification.html" title="Theorem 1.2">Theorem 1.2</a>. Our method is based on Lemma 3.10 of <a class="xref" data-knowl="./knowl/Cornulier-2016-gradings.html" title="Bibliographic Entry 6: Gradings on Lie algebras, systolic growth, and cohopfian properties of nilpotent groups">[6]</a>, which gives the following characterization of stratifiable Lie algebras:</p>
<article class="lemma theorem-like" id="lemma-stratification-by-derivation"><h6 class="heading">
<span class="type">Lemma</span><span class="space"> </span><span class="codenumber">3.2</span><span class="period">.</span>
</h6>
<p id="p-93">A nilpotent Lie algebra \(\mathfrak{g}\) is <a class="xref" data-knowl="./knowl/def-stratification.html" title="Definition 3.1">stratifiable</a> if and only if there exists a derivation \(\delta\colon\mathfrak{g}\to\mathfrak{g}\) such that the induced map \(\mathfrak{g}/[\mathfrak{g},\mathfrak{g}]\to \mathfrak{g}/[\mathfrak{g},\mathfrak{g}]\) is the identity map. Moreover, a stratification is given by the <a class="xref" data-knowl="./knowl/def-grading.html" title="Definition 2.1">layers</a> \(V_i=\ker (\delta-i)\text{.}\)</p></article><p id="p-94">The condition of <a class="xref" data-knowl="./knowl/lemma-stratification-by-derivation.html" title="Lemma 3.2">Lemma 3.2</a> is straightforward to check in a basis <a class="xref" data-knowl="./knowl/def-basis-adapted-to-lcs.html" title="Definition 3.3">adapted to the lower central series</a>.</p>
<article class="definition definition-like" id="def-basis-adapted-to-lcs"><h6 class="heading">
<span class="type">Definition</span><span class="space"> </span><span class="codenumber">3.3</span><span class="period">.</span>
</h6>
<p id="p-95">The lower central series of a Lie algebra \(\mathfrak{g}\) is the decreasing sequence of subspaces</p>
<div class="displaymath">
\begin{equation*}
\mathfrak{g}=\mathfrak{g}^{(1)}\supset \mathfrak{g}^{(2)}\supset \mathfrak{g}^{(3)}\supset\cdots\text{,}
\end{equation*}
</div>
<p data-braille="continuation">where \(\mathfrak{g}^{(i+1)} = [\mathfrak{g},\mathfrak{g}^{(i)}]\text{.}\) A basis \(X_1,\dots,X_n\) of a Lie algebra \(\mathfrak{g}\) is <dfn class="terminology">adapted to the lower central series</dfn> if for every non-zero \(\mathfrak{g}^{(i)}\) there exists an index \(n_i\in\mathbb{N}\) such that \(X_{n_i},\dots,X_n\) is a basis of \(\mathfrak{g}^{(i)}\text{.}\) The <dfn class="terminology">degree</dfn> of the basis element \(X_i\) is the integer \(w_i=\max\{j\in\mathbb{N}: X_i\in\mathfrak{g}^{(j)}\}\text{.}\)</p></article><article class="proposition theorem-like" id="prop-stratification-explicit-leibniz"><h6 class="heading">
<span class="type">Proposition</span><span class="space"> </span><span class="codenumber">3.4</span><span class="period">.</span>
</h6>
<p id="p-96">Let \(X_1,\ldots,X_n\) be a basis <a class="xref" data-knowl="./knowl/def-basis-adapted-to-lcs.html" title="Definition 3.3">adapted to the lower central series</a> of a nilpotent Lie algebra \(\mathfrak{g}\) defined over a field \(F\text{.}\) Let \(w_1,\ldots,w_n\) be the <a class="xref" data-knowl="./knowl/def-basis-adapted-to-lcs.html" title="Definition 3.3">degrees</a>  of the basis elements and let \(c_{ij}^k\in F\) be the <a class="xref" data-knowl="./knowl/par-structure-coefficients.html" title="Paragraph">structure coefficients</a> in the basis. A linear map \(\delta\colon\mathfrak{g}\to\mathfrak{g}\) is a derivation that restricts to the identity on \(\mathfrak{g}/[\mathfrak{g},\mathfrak{g}]\) if and only if</p>
<div class="displaymath">
\begin{equation}
\delta(X_i) = w_iX_i + \sum_{w_j\gt w_i}a_{ij}X_j\label{eq-derivation-in-lcs-basis}\tag{3.1}
\end{equation}
</div>
<p data-braille="continuation">such that, for each triple of indices \(i,j,k\) such that \(w_k\gt w_i+w_j\text{,}\) the coefficients \(a_{ij}\in F\) satisfy the linear equation</p>
<div class="displaymath">
\begin{align}
c_{ij}^k(w_k-w_i-w_j) = \amp\sum_{w_i\lt w_h\leq w_k-w_j}a_{ih}c_{hj}^k+\sum_{w_j\lt w_h\leq w_k-w_i}a_{jh}c_{ih}^k\label{eq-stratifying-leibniz-condition}\tag{3.2}\\
-\amp\sum_{w_i+w_j\leq w_h\lt w_k}c_{ij}^ha_{hk}\text{.}\notag
\end{align}
</div></article><article class="hiddenproof" id="proof-9"><a data-knowl="" class="id-ref original" data-refid="hk-proof-9"><h6 class="heading"><span class="type">Proof<span class="period">.</span></span></h6></a></article><div class="hidden-content tex2jax_ignore" id="hk-proof-9"><article class="hiddenproof"><p id="p-97">If \(\delta\colon\mathfrak{g}\to\mathfrak{g}\) is a derivation that restricts to the identity on \(\mathfrak{g}/[\mathfrak{g},\mathfrak{g}]\text{,}\) then by <a class="xref" data-knowl="./knowl/lemma-stratification-by-derivation.html" title="Lemma 3.2">Lemma 3.2</a> \(\mathfrak{g}\) admits a <a class="xref" data-knowl="./knowl/def-stratification.html" title="Definition 3.1">stratification</a></p>
<div class="displaymath">
\begin{equation*}
\mathfrak{g}=V_1\oplus\dots\oplus V_s
\end{equation*}
</div>
<p data-braille="continuation">such that \(\restr{\delta}{V_i} = i\cdot \operatorname{id}\text{.}\) Since the terms of the lower central series are given in terms of the stratification as \(\mathfrak{g}^{(i)}=V_i\oplus\dots\oplus V_s \text{,}\) it follows that \(\delta(Y)\in i\cdot Y+\mathfrak{g}^{(i+1)}\) for any \(Y\in\mathfrak{g}^{(i)}\text{.}\) That is, a derivation \(\delta\) restricting to the identity on \(\mathfrak{g}/[\mathfrak{g},\mathfrak{g}]\) is of the form <a class="xref" data-knowl="./knowl/eq-derivation-in-lcs-basis.html" title="Equation 3.1">(3.1)</a> for some coefficients \(a_{ij}\in F\text{.}\)</p>
<p id="p-98">It is then enough to show that <a class="xref" data-knowl="./knowl/eq-stratifying-leibniz-condition.html" title="Equation 3.2">(3.2)</a> is equivalent to the Leibniz rule</p>
<div class="displaymath">
\begin{equation*}
\delta([X_i,X_j]) = [\delta(X_i),X_j]+[X_i,\delta(X_j)],\quad \forall i,j\in\{1,\ldots,n\}\text{.}
\end{equation*}
</div>
<p data-braille="continuation">Indeed, this would prove that a linear map defined by <a class="xref" data-knowl="./knowl/eq-derivation-in-lcs-basis.html" title="Equation 3.1">(3.1)</a> is a derivation if and only if the coefficients \(a_{ij}\) satisfy the linear system <a class="xref" data-knowl="./knowl/eq-stratifying-leibniz-condition.html" title="Equation 3.2">(3.2)</a>.</p>
<p id="p-99">Since the basis \(X_i\) is adapted to the lower central series, only the structure coefficients with large enough degrees are non-zero, i.e., we have</p>
<div class="displaymath">
\begin{equation}
[X_i,X_j] = \sum_{w_k\geq w_i+w_j}c_{ij}^kX_k\text{.}\label{eq-lcs-basis-structure-coefficients}\tag{3.3}
\end{equation}
</div>
<p data-braille="continuation">By direct computation using <a class="xref" data-knowl="./knowl/eq-derivation-in-lcs-basis.html" title="Equation 3.1">(3.1)</a> and <a class="xref" data-knowl="./knowl/eq-lcs-basis-structure-coefficients.html" title="Equation 3.3">(3.3)</a> we get the expressions</p>
<div class="displaymath">
\begin{align*}
[\delta(X_i),X_j] \amp =  \sum_{w_k\geq w_i+w_j}c_{ij}^kw_iX_k + \sum_{w_h\gt w_i}\sum_{w_k\geq w_h+w_j}a_{ih}c_{hj}^kX_k\\
[X_i,\delta(X_j)] \amp = \sum_{w_k\geq w_i+w_j}c_{ij}^kw_jX_k + \sum_{w_h\gt w_j}\sum_{w_k\geq w_i+w_h}a_{jh}c_{ih}^kX_k\\
\delta([X_i,X_j]) \amp = \sum_{w_k\geq w_i+w_j}c_{ij}^kw_kX_k + \sum_{w_h\geq w_i+w_j}\sum_{w_k\gt w_h}c_{ij}^ha_{hk}X_k
\end{align*}
</div>
<p data-braille="continuation">Denoting \(\sum_k B_{ij}^kX_k = \delta([X_i,X_j])-[\delta(X_i),X_j]-[X_i,\delta(X_j)]\text{,}\) we find that the equation \(B_{ij}^k=0\) is up to reorganizing terms equivalent to <a class="xref" data-knowl="./knowl/eq-stratifying-leibniz-condition.html" title="Equation 3.2">(3.2)</a>.</p>
<p id="p-100">Finally, we observe that when \(w_k\leq w_i+w_j\text{,}\) the condition \(B_{ij}^k=0\) is automatically satisfied: for \(w_k\lt w_i+w_j\) all of the sums are empty, and for \(w_k=w_i+w_j\text{,}\) the only remaining terms from the sums cancel out as</p>
<div class="displaymath">
\begin{equation*}
B_{ij}^k = c_{ij}^kw_k-c_{ij}^kw_i-c_{ij}^kw_j=0\text{.}
\end{equation*}
</div></article></div>
<p id="p-101">The concrete criterion of <a class="xref" data-knowl="./knowl/prop-stratification-explicit-leibniz.html" title="Proposition 3.4">Proposition 3.4</a> provides the algorithm of <a class="xref" data-knowl="./knowl/theorem-stratification.html" title="Theorem 1.2">Theorem 1.2</a>.</p>
<article class="algorithm theorem-like" id="algorithm-stratification"><h6 class="heading">
<span class="type">Algorithm</span><span class="space"> </span><span class="codenumber">3.5</span><span class="period">.</span><span class="space"> </span><span class="title">Stratification.</span>
</h6>
<p id="p-102">Input: A nilpotent Lie algebra \(\mathfrak{g}\text{.}\) Output: A <a class="xref" data-knowl="./knowl/def-stratification.html" title="Definition 3.1">stratification</a> of \(\mathfrak{g}\) or the non-existence of one.</p>
<ol class="decimal">
<li id="alg-stratification-1-lcs">Construct a basis \(X_1,\ldots,X_n\) <a class="xref" data-knowl="./knowl/def-basis-adapted-to-lcs.html" title="Definition 3.3">adapted to the lower central series</a>.</li>
<li id="alg-stratification-2-leibniz">Find a derivation \(\delta\) as in <a class="xref" data-knowl="./knowl/eq-derivation-in-lcs-basis.html" title="Equation 3.1">(3.1)</a> solving the linear system <a class="xref" data-knowl="./knowl/eq-stratifying-leibniz-condition.html" title="Equation 3.2">(3.2)</a>. If the system has no solutions, then \(\mathfrak{g}\) is not <a class="xref" data-knowl="./knowl/def-stratification.html" title="Definition 3.1">stratifiable</a>.</li>
<li id="alg-stratification-3-layers">Return the stratification with the <a class="xref" data-knowl="./knowl/def-grading.html" title="Definition 2.1">layers</a> \(V_i=\ker (\delta-i)\text{.}\)</li>
</ol></article></section><section class="subsection" id="sssec-pos-gradings"><h3 class="heading hide-type">
<span class="type">Subsection</span> <span class="codenumber">3.2</span> <span class="title">Positive gradings</span>
</h3>
<article class="definition definition-like" id="def-positive-grading"><h6 class="heading">
<span class="type">Definition</span><span class="space"> </span><span class="codenumber">3.6</span><span class="period">.</span>
</h6>
<p id="p-103">An <a class="xref" data-knowl="./knowl/def-grading.html" title="Definition 2.1">\(\mathbb{R}\)-grading</a> \(\mathcal{V} \colon \mathfrak{g} = \bigoplus_{\alpha \in \mathbb{R}} V_\alpha \) is <dfn class="terminology">positive</dfn> if \(\alpha\gt 0\) for all the <a class="xref" data-knowl="./knowl/def-grading.html" title="Definition 2.1">weights</a> of \(\mathcal{V}\text{.}\) If such a grading exists for \(\mathfrak{g}\text{,}\) then \(\mathfrak{g}\) is said to be <dfn class="terminology">positively gradable</dfn>.</p></article><p id="p-104">One of our main goals is to determine when a grading admits a positive realization, i.e., can be realized as a positive grading. A characterization is given in Proposition 3.22 of <a class="xref" data-knowl="./knowl/Cornulier-2016-gradings.html" title="Bibliographic Entry 6: Gradings on Lie algebras, systolic growth, and cohopfian properties of nilpotent groups">[6]</a>. In the lemma and proposition below, we provide constructive proofs for this characterization.</p>
<article class="lemma theorem-like" id="prop-Z-gradings-to-positive-forward"><h6 class="heading">
<span class="type">Lemma</span><span class="space"> </span><span class="codenumber">3.7</span><span class="period">.</span>
</h6>
<p id="p-105">Let \(m \ge 1\) and let \(\mathcal{V} \) be a <a class="xref" data-knowl="./knowl/def-grading.html" title="Definition 2.1">\(\mathbb{Z}^m\)-grading</a> of a Lie algebra \(\mathfrak{g}\text{.}\) Suppose the convex hull of the set of <a class="xref" data-knowl="./knowl/def-grading.html" title="Definition 2.1">weights</a> of \(\mathcal{V} \) does not contain the origin. Then there exists a homomorphism \(f \colon \mathbb{Z}^m \to \mathbb{Z}\) whose restriction on the weights is injective and positive.</p></article><article class="hiddenproof" id="proof-10"><a data-knowl="" class="id-ref original" data-refid="hk-proof-10"><h6 class="heading"><span class="type">Proof<span class="period">.</span></span></h6></a></article><div class="hidden-content tex2jax_ignore" id="hk-proof-10"><article class="hiddenproof"><p id="p-106">Let us consider the natural embedding of \(\mathbb{Z}^m\) into \(\mathbb{Q}^m\text{.}\) Using the canonical inner product \(\langle\cdot,\cdot\rangle\) on \(\mathbb{Q}^m\text{,}\) we define for each vector \(v \in \mathbb{Q}^m\text{,}\) the corresponding open half-space</p>
<div class="displaymath">
\begin{equation*}
M_v = \{x\in \mathbb{Q}^m : \langle v, x \rangle &gt; 0 \}\text{.}
\end{equation*}
</div>
<p id="p-107">Denote by \(\Omega= \{\alpha_1,\ldots,\alpha_N\}\) the set of weights of \(\mathcal{V}\text{.}\) Recall that the convex hull of a set is the intersection of all the affine half-spaces containing the set. Hence, because the convex hull of \(\Omega\) does not contain the origin, it is contained in an open half-space \(M_{v_0} \subset \mathbb{Q}^m\text{.}\) Moreover, there exists a neighborhood \(B\) of \(v_0\) such that the convex hull of \(\Omega\) is contained in every half-space \(M_v\) with \(v\in B\text{.}\)</p>
<p id="p-108">By construction all the inner products \(\langle v, \alpha_i \rangle\) with \(\alpha_i \in \Omega\) and \(v\in B\) are strictly positive. Since \(B\) has non-empty interior, we may choose some \(v\in B\) such that all the numbers \(\langle v, \alpha_1 \rangle , \ldots, \langle v, \alpha_N \rangle \) are strictly positive and distinct. Rescaling \(v\) to eliminate denominators, we obtain a vector \(\tilde{v} \in \mathbb{Z}^m\text{,}\) and the map \(f(\cdot)=\langle \tilde{v}, \cdot \rangle\) is the required homomorphism \(\mathbb{Z}^m \to \mathbb{Z}\text{.}\) Concretely, a valid vector \(\tilde{v}\) can be found directly by just enumerating the points of \(\mathbb{Z}^k\) with increasing distance from the origin and testing one by one if all the inner products with the weights are positive and distinct.</p></article></div>
<article class="proposition theorem-like" id="prop-Z-gradings-to-positive-backward"><h6 class="heading">
<span class="type">Proposition</span><span class="space"> </span><span class="codenumber">3.8</span><span class="period">.</span>
</h6>
<p id="p-109">Let \(\mathcal{W}\) be a <a class="xref" data-knowl="./knowl/def-torsion-free-grading.html" title="Definition 2.3">torsion-free grading</a>. Then \(\mathcal{W}\) admits a <a class="xref" data-knowl="./knowl/def-positive-grading.html" title="Definition 3.6">positive</a> <a class="xref" data-knowl="./knowl/def-realization.html" title="Definition 2.2">realization</a> if and only if the convex hull of the set of <a class="xref" data-knowl="./knowl/def-grading.html" title="Definition 2.1">weights</a> of the <a class="xref" data-knowl="./knowl/def-universal-realization.html" title="Definition 2.12">universal realization</a> of \(\mathcal{W}\) does not contain the origin.</p></article><article class="hiddenproof" id="proof-11"><a data-knowl="" class="id-ref original" data-refid="hk-proof-11"><h6 class="heading"><span class="type">Proof<span class="period">.</span></span></h6></a></article><div class="hidden-content tex2jax_ignore" id="hk-proof-11"><article class="hiddenproof"><p id="p-110">We only need to prove the forward implication due to <a class="xref" data-knowl="./knowl/prop-Z-gradings-to-positive-forward.html" title="Lemma 3.7">Lemma 3.7</a>. Let \(\mathcal{V}\) be a positive realization of \(\mathcal{W}\) and let \(\widetilde{\mathcal{W}}\) be the universal realization of \(\mathcal{W}\text{,}\) which by <a class="xref" data-knowl="./knowl/lemma-universal-realization-Zk.html" title="Lemma 2.14">Lemma 2.14</a> is a \(\mathbb{Z}^k\)-grading. Then by the definition of a universal realization there is a homomorphism \(f \colon \mathbb{Z}^k \to \mathbb{R}\) such that <a class="xref" data-knowl="./knowl/def-push-forward-grading.html" title="Definition 2.5">\(\mathcal{V}= f_* \widetilde{\mathcal{W}}\)</a>. Consider the vector \(v = (f(e_1),\ldots,f(e_k)) \in \mathbb{R}^k\text{,}\) where \(e_1,\ldots, e_k\) are the standard basis vectors of \(\mathbb{Z}^k\text{,}\) and express \(f\) as \(f(\cdot)= \langle v, \cdot \rangle\text{.}\) Since \(\mathcal{V}\) is a positive grading, then for all weights \(\alpha\) of \(\widetilde{\mathcal{W}}\) we have \(f(\alpha) \gt 0 \text{,}\) that is, \(\langle v, \alpha \rangle \gt 0\text{.}\) Hence all the weights belong to the open half-space determined by the vector \(v\text{,}\) and so the origin is not contained in their convex hull.</p></article></div>
<p id="p-111">The above results give the following algorithm for <a class="xref" data-knowl="./knowl/theorem-positivizable-grading.html" title="Theorem 1.5">Theorem 1.5</a>.<a class="xref" data-knowl="./knowl/theorem-positivizable-grading-li1.html" title="Item i">i</a>. We stress that we do not need to assume that the base field of \(\mathfrak{g}\) is algebraically closed.</p>
<article class="algorithm theorem-like" id="algorithm-positivisable-Zk"><h6 class="heading">
<span class="type">Algorithm</span><span class="space"> </span><span class="codenumber">3.9</span><span class="period">.</span><span class="space"> </span><span class="title">Positive realization.</span>
</h6>
<p id="p-112">Input: A <a class="xref" data-knowl="./knowl/def-torsion-free-grading.html" title="Definition 2.3">torsion-free grading</a> \(\mathcal{V}\) for a Lie algebra \(\mathfrak{g}\text{.}\) Output: A <a class="xref" data-knowl="./knowl/def-positive-grading.html" title="Definition 3.6">positive</a> <a class="xref" data-knowl="./knowl/def-realization.html" title="Definition 2.2">realization</a> of \(\mathcal{V}\) or the non-existence of one.</p>
<ol class="decimal">
<li id="li-11">Compute the <a class="xref" data-knowl="./knowl/def-universal-realization.html" title="Definition 2.12">universal realization</a> \(\widetilde{\mathcal{V}}\) of \(\mathcal{V}\) using <a class="xref" data-knowl="./knowl/algorithm-integer-vector-grading.html" title="Algorithm 2.13: Universal realization">Algorithm 2.13</a>. Let \(\mathbb{Z}^k\) be the grading group of \(\widetilde{\mathcal{V}}\text{.}\)</li>
<li id="alg-pos-convex-hull">If the convex hull of the <a class="xref" data-knowl="./knowl/def-grading.html" title="Definition 2.1">weights</a> of \(\widetilde{\mathcal{V}}\) contains the origin, then no positive realization exists.</li>
<li id="alg-pos-projection">Otherwise, find a vector \(v \in \mathbb{Z}^k\) so that the homomorphism \(f\colon \mathbb{Z}^k\to\mathbb{Z}\text{,}\) \(f(\cdot)=\langle v,\cdot\rangle\) maps all weights of \(\widetilde{\mathcal{V}}\) to distinct positive integers.</li>
<li id="alg-pos-push-forward">Return the <a class="xref" data-knowl="./knowl/def-push-forward-grading.html" title="Definition 2.5">push-forward grading</a> \(f_*\widetilde{\mathcal{V}}\text{.}\)</li>
</ol></article><p id="p-113">The algorithm for <a class="xref" data-knowl="./knowl/theorem-positivizable-grading.html" title="Theorem 1.5">Theorem 1.5</a>.<a class="xref" data-knowl="./knowl/theorem-positivizable-grading-li2.html" title="Item ii">ii</a> is somewhat similar to <a class="xref" data-knowl="./knowl/algorithm-positivisable-Zk.html" title="Algorithm 3.9: Positive realization">Algorithm 3.9</a>.  Suppose we have an <a class="xref" data-knowl="./knowl/def-grading.html" title="Definition 2.1">\(S\)-grading</a> \(\mathcal{V}\) for a finitely generated abelian group \(S\text{,}\) and we want to find a homomorphism \(S\to\mathbb{R}\) turning it into a <a class="xref" data-knowl="./knowl/def-positive-grading.html" title="Definition 3.6">positive grading</a>. If some element of \(S\) has torsion, then no such homomorphism can exist. Otherwise, \(S\) is isomorphic to \(\mathbb{Z}^k\) for some \(k \ge 1\) and we may follow steps <a class="xref" data-knowl="./knowl/alg-pos-convex-hull.html" title="Item 2">2</a>-<a class="xref" data-knowl="./knowl/alg-pos-projection.html" title="Item 3">Item 3</a> of the above algorithm to obtain a homomorphism \(S\to\mathbb{R}\) giving a positive realization if one exists.</p>
<article class="remark remark-like" id="remark-every-grading-is-R-grading"><h6 class="heading">
<span class="type">Remark</span><span class="space"> </span><span class="codenumber">3.10</span><span class="period">.</span>
</h6>
<p id="p-114">The argument of <a class="xref" data-knowl="./knowl/prop-Z-gradings-to-positive-forward.html" title="Lemma 3.7">Lemma 3.7</a> can also be used to find a <a class="xref" data-knowl="./knowl/def-realization.html" title="Definition 2.2">realization</a> over \(\mathbb{Z}\) for any <a class="xref" data-knowl="./knowl/def-torsion-free-grading.html" title="Definition 2.3">torsion-free grading</a> \(\mathcal{V}\text{.}\) Indeed, first consider the <a class="xref" data-knowl="./knowl/def-universal-realization.html" title="Definition 2.12">universal realization</a> of \(\mathcal V\) over some \(\mathbb{Z}^k\text{.}\) Then disregarding the discussion about half-spaces and positivity, find a <a class="xref" data-knowl="./knowl/def-push-forward-grading.html" title="Definition 2.5">push-forward</a> to \(\mathbb{Z}\) by constructing a vector \(v\) for which the projection is injective on the <a class="xref" data-knowl="./knowl/def-grading.html" title="Definition 2.1">weights</a>.</p></article><article class="remark remark-like" id="remark-enumerating-gradings"><h6 class="heading">
<span class="type">Remark</span><span class="space"> </span><span class="codenumber">3.11</span><span class="period">.</span>
</h6>
<p id="p-115">The results we have established can also be used to explicitly enumerate the <a class="xref" data-knowl="./knowl/def-positive-grading.html" title="Definition 3.6">positive gradings</a> of a given Lie algebra \(\mathfrak{g}\) over an algebraically closed field, in two different senses.</p>
<ol class="lower-roman">
<li id="li-param-of-pos-gradings">Consider the <a class="xref" data-knowl="./knowl/def-maximal-grading.html" title="Definition 2.21">maximal grading</a> \(\mathcal{V}\) of \(\mathfrak{g}\) over \(\mathbb{Z}^k\text{.}\) Up to automorphism, positive gradings of \(\mathfrak{g}\) are given by the projections from \(\mathbb{Z}^k\) to \(\mathbb{R}\) mapping the <a class="xref" data-knowl="./knowl/def-grading.html" title="Definition 2.1">weights</a> of \(\mathcal{V}\) to strictly positive numbers. A parametrisation of these projections gives a parametrisation of positive gradings.</li>
<li id="li-16">Construct all the gradings of \(\mathfrak{g}\) as in <a class="xref" data-knowl="./knowl/prop-Quot-gradings-are-everything.html" title="Proposition 2.25">Proposition 2.25</a> (using a maximal grading constructed in <a class="xref" data-knowl="./knowl/algorithm-maximal-grading.html" title="Algorithm 3.12: Maximal grading">Algorithm 3.12</a>). Then check one by one which of them admit positive <a class="xref" data-knowl="./knowl/def-realization.html" title="Definition 2.2">realizations</a>. This produces a finite list of positive gradings so that every positive grading of \(\mathfrak{g}\) is <a class="xref" data-knowl="./knowl/def-equivalent-gradings.html" title="Definition 2.9">equivalent</a> in the sense of <a class="xref" data-knowl="./knowl/def-equivalent-gradings.html" title="Definition 2.9">Definition 2.9</a> to one of the elements on the list.</li>
</ol></article><p id="p-116">The algorithm of <a class="xref" data-knowl="./knowl/theorem-positive-grading.html" title="Theorem 1.3">Theorem 1.3</a> is given by applying <a class="xref" data-knowl="./knowl/algorithm-positivisable-Zk.html" title="Algorithm 3.9: Positive realization">Algorithm 3.9</a> to the maximal grading of a Lie algebra. Indeed, if some grading admits a positive realization, then by <a class="xref" data-knowl="./knowl/prop-max-grading.html" title="Proposition 2.23">Proposition 2.23</a> the maximal grading admits a positive realization as well. For the maximal grading, a positive realization if one exists is given by <a class="xref" data-knowl="./knowl/algorithm-positivisable-Zk.html" title="Algorithm 3.9: Positive realization">Algorithm 3.9</a>.</p>
<p id="p-117">The existence of a positive realization of a grading can also be phrased as the existence of a solution to a linear system. This viewpoint gives rise to an alternate elementary algorithm to determine whether a positive realization exists, as we explain in <a href="section-positive-gradings.html" class="internal" title="Appendix A: Existence of a positive realization">Appendix A</a>.</p></section><section class="subsection" id="section-maximal-construction"><h3 class="heading hide-type">
<span class="type">Subsection</span> <span class="codenumber">3.3</span> <span class="title">Maximal gradings</span>
</h3>
<p id="p-118">In this section we prove <a class="xref" data-knowl="./knowl/theorem-maximal-grading.html" title="Theorem 1.1">Theorem 1.1</a> by providing an algorithm to construct a maximal grading for a Lie algebra \(\mathfrak{g}\) defined over an algebraically closed field of characteristic zero. In this setting, every torus is split. The method we use to compute maximal gradings is the following.</p>
<article class="algorithm theorem-like" id="algorithm-maximal-grading"><h6 class="heading">
<span class="type">Algorithm</span><span class="space"> </span><span class="codenumber">3.12</span><span class="period">.</span><span class="space"> </span><span class="title">Maximal grading.</span>
</h6>
<p id="p-119">Input: A Lie algebra \(\mathfrak{g}\) over an algebraically closed field \(F\text{.}\) Output: A <a class="xref" data-knowl="./knowl/def-maximal-grading.html" title="Definition 2.21">maximal grading</a> of \(\mathfrak{g}\text{.}\)</p>
<ol class="decimal">
<li id="maxalg-1-derivations">Compute a basis for the derivation algebra \(\der(\mathfrak{g})\text{.}\) Set \(B= \emptyset\text{.}\)</li>
<li id="maxalg-2-eigenspace-grading">Determine the \(\mathfrak{t}^*\)-grading \(\mathcal{V}:\mathfrak{g}=\bigoplus_\lambda V_\lambda\) <a class="xref" data-knowl="./knowl/def-grading-induced-by-torus.html" title="Definition 2.18">induced by the torus</a> \(\mathfrak{t}=\langle B\rangle\text{.}\)</li>
<li id="maxalg-3-centralizer">Compute a basis \(A_1,\ldots,A_n\) for the centralizer \(C(\mathfrak{t})\subset \der(\mathfrak{g})\text{.}\)</li>
<li id="maxalg-4-ad-rep">Compute the adjoint representation \(\ad\colon C(\mathfrak{t})\to \bigoplus_{\lambda}\mathfrak{gl}(\mathfrak{gl}(V_\lambda))\text{.}\)</li>
<li id="maxalg-5-ad-kernel">Compute a basis \(K_1,\ldots,K_m\) for \(\ker(\ad)\subset C(\mathfrak{t})\text{.}\) If \(K_{i}\notin \mathfrak{t}\) for some \(i=1,\ldots,m\text{,}\) extend \(\mathfrak{t}\) by \(K_{i}\) and go back to step <a class="xref" data-knowl="./knowl/maxalg-2-eigenspace-grading.html" title="Item 2">2</a>.</li>
<li id="maxalg-6-nonnilpotent-element">Repeat for each \(A=A_i\) and \(A=A_i+A_j\text{,}\) \(i,j=1,\ldots,n\text{:}\) compute the Jordan decomposition \(A=A_s+A_n\text{.}\) If \(A_s\notin \mathfrak{t}\text{,}\) extend \(\mathfrak{t}\) by \(A_s\) and go back to step <a class="xref" data-knowl="./knowl/maxalg-2-eigenspace-grading.html" title="Item 2">2</a>.</li>
<li id="maxalg-7-zk-indexing">Compute and return the <a class="xref" data-knowl="./knowl/def-universal-realization.html" title="Definition 2.12">universal realization</a> of the grading \(\mathcal{V}\text{.}\)</li>
</ol></article><p id="p-120">The rest of the section is devoted to proving the correctness of <a class="xref" data-knowl="./knowl/algorithm-maximal-grading.html" title="Algorithm 3.12: Maximal grading">Algorithm 3.12</a> and to explaining the steps in more detail. Step <a class="xref" data-knowl="./knowl/maxalg-6-nonnilpotent-element.html" title="Item 6">6</a> is the most involved part.</p>
<p id="p-121">Step <a class="xref" data-knowl="./knowl/maxalg-1-derivations.html" title="Item 1">1</a> is straightforward linear algebra. In step <a class="xref" data-knowl="./knowl/maxalg-2-eigenspace-grading.html" title="Item 2">2</a>, the grading induced by the torus \(\mathfrak{t}\) has a concrete description in terms of a fixed basis of \(\mathfrak{t}\text{.}\) Namely, a basis \(\delta_1,\ldots,\delta_k\) defines an isomorphism \(\mathfrak{t}^*\to F^k\) and hence an <a class="xref" data-knowl="./knowl/def-equivalent-group-gradings.html" title="Definition 2.8">equivalent</a> <a class="xref" data-knowl="./knowl/def-push-forward-grading.html" title="Definition 2.5">push-forward grading</a> over \(F^k\text{.}\) Expanding out the construction of <a class="xref" data-knowl="./knowl/lemma-gradings-induced.html" title="Lemma 2.17">Lemma 2.17</a> shows that the push-forward grading has the <a class="xref" data-knowl="./knowl/def-grading.html" title="Definition 2.1">layers</a></p>
<div class="displaymath">
\begin{equation*}
V_\lambda = V_{(\lambda_1,\ldots,\lambda_k)}
= \bigcap_{i=1}^k E^{\lambda_i}_{\delta_i}\text{,}
\end{equation*}
</div>
<p data-braille="continuation">where \(E^{\lambda_i}_{\delta_i}\) is the (possibly zero) eigenspace for the eigenvalue \(\lambda_i\) of the derivation \(\delta_i\text{.}\)</p>
<p id="p-122">Step <a class="xref" data-knowl="./knowl/maxalg-3-centralizer.html" title="Item 3">3</a> is another straightforward linear algebra computation. In step <a class="xref" data-knowl="./knowl/maxalg-4-ad-rep.html" title="Item 4">4</a>, the key observation is that any linear map \(A\in C(\mathfrak{t})\) preserves the eigenspaces of all the derivations \(\delta\in\mathfrak{t}\text{.}\) Hence such a linear map \(A\) also preserves the layers \(V_\lambda\) of the \(F^k\)-grading. It follows that each map \(\ad(A)\) restricts to a linear map \(\ad(A)\colon \mathfrak{gl}(V_\lambda)\to \mathfrak{gl}(V_\lambda)\) for each weight \(\lambda\text{.}\) The direct sum of these representations gives the representation \(\ad\colon C(\mathfrak{t})\to \bigoplus_{\lambda}\mathfrak{gl}(\mathfrak{gl}(V_\lambda))\text{.}\)</p>
<p id="p-123">Step <a class="xref" data-knowl="./knowl/maxalg-5-ad-kernel.html" title="Item 5">5</a> captures the situation when the torus \(\mathfrak{t}\) can be extended without <a class="xref" data-knowl="./knowl/def-same-layers.html" title="Definition 2.6">refining</a> the grading. Indeed, the elements of the kernel of \(\ad\) are the elements \(A\in C(\mathfrak{t})\) whose restrictions commute with all other maps in \(\mathfrak{gl}(V_\lambda)\) for each weight \(\lambda\text{.}\) That is, they are the maps \(A\in C(\mathfrak{t})\) such that each \(\restr{A}{V_\lambda}\) is a multiple of the identity. The eigenspaces of such maps are sums of the layers \(V_\lambda\text{,}\) so they do not further refine the grading induced by \(\mathfrak{t}\text{,}\) as seen in the following example.</p>
<article class="example example-like" id="example-heisenberg-torus-extension"><a data-knowl="" class="id-ref original" data-refid="hk-example-heisenberg-torus-extension"><h6 class="heading">
<span class="type">Example</span><span class="space"> </span><span class="codenumber">3.13</span><span class="period">.</span>
</h6></a></article><div class="hidden-content tex2jax_ignore" id="hk-example-heisenberg-torus-extension"><article class="example example-like"><p id="p-124">Let \(\mathfrak{h}\) be the Heisenberg Lie algebra with the only bracket \([X,Y]=Z\text{.}\) Consider the derivation</p>
<div class="displaymath">
\begin{equation*}
\delta\colon\mathfrak{h}\to\mathfrak{h},\quad \delta(X)=X,\quad\delta(Y)=2Y,\quad\delta(Z)=3Z\text{.}
\end{equation*}
</div>
<p data-braille="continuation">The grading induced by \(\delta\) is \(\mathfrak{h}=V_1\oplus V_2\oplus V_3=\langle X\rangle\oplus\langle Y\rangle \oplus \langle Z\rangle\text{.}\)</p>
<p id="p-125">The centralizer of \(\delta\) in \(\der(\mathfrak{h})\) is the two-dimensional space \(C(\delta)=\langle \delta_1,\delta_2\rangle\text{,}\) where the two basis derivations are defined by</p>
<div class="displaymath">
\begin{align*}
\delta_1(X)\amp = X,\amp \delta_1(Y)\amp = 0,\amp \delta_1(Z)\amp = Z,\\
\delta_2(X)\amp = 0,\amp \delta_2(Y)\amp = Y,\amp \delta_1(Z)\amp = Z\text{.}
\end{align*}
</div>
<p data-braille="continuation">The one-dimensional Lie algebras \(\mathfrak{gl}(V_i)\) are all abelian, so the adjoint representation \(\ad\colon C(\delta)\to \mathfrak{gl}(\mathfrak{gl}(V_1))\oplus \mathfrak{gl}(\mathfrak{gl}(V_2))\oplus \mathfrak{gl}(\mathfrak{gl}(V_3))\) is just the zero map. Both \(\{\delta,\delta_1\}\) and \(\{\delta,\delta_2\}\) span strictly bigger tori than \(\{\delta\}\text{,}\) but neither torus further refines the original grading \(\mathfrak{h}=V_1\oplus V_2\oplus V_3\text{:}\) for instance, the grading induced by \(\langle\delta,\delta_1\rangle\) is \(V_{(1,1)}\oplus V_{(2,0)}\oplus V_{(3,
1)} =\langle X\rangle\oplus\langle Y\rangle \oplus \langle Z\rangle \text{.}\)</p></article></div>
<p id="p-126">Step <a class="xref" data-knowl="./knowl/maxalg-6-nonnilpotent-element.html" title="Item 6">6</a> is the most intricate part of <a class="xref" data-knowl="./knowl/algorithm-maximal-grading.html" title="Algorithm 3.12: Maximal grading">Algorithm 3.12</a>. To prove its correctness, we need to show that if \(A_s\in\mathfrak{t}\) for all basis elements \(A=A_i\) and all their sums \(A=A_i+A_j\text{,}\) then the torus \(\mathfrak{t}\) is maximal. The proof is based on the efficient criterion of Proposition 2.6.11 of <a class="xref" data-knowl="./knowl/deGraaf-2017-computation_with_linear_algebraic_groups.html" title="Bibliographic Entry 12: Computation with linear algebraic groups">[12]</a>:</p>
<article class="lemma theorem-like" id="lemma-nonnilpotent-element"><h6 class="heading">
<span class="type">Lemma</span><span class="space"> </span><span class="codenumber">3.14</span><span class="period">.</span>
</h6>
<p id="p-127">Let \(\mathfrak{c}\) be a Lie algebra and let \(X_1,\ldots,X_n\) be a basis of \(\mathfrak{c}\text{.}\) If \(\ad(X_i)\) is nilpotent for \(1\leq i\leq n\) and \(\ad(X_i+X_j)\) is nilpotent for all \(1\leq i\lt j\leq n\text{,}\) then \(\ad(X)\) is nilpotent for all \(X\in\mathfrak{c}\text{.}\)</p></article><p id="p-128">To make use of the criterion <a class="xref" data-knowl="./knowl/lemma-nonnilpotent-element.html" title="Lemma 3.14">Lemma 3.14</a>, we also need the fact the Jordan decomposition is preserved by the adjoint representation.</p>
<article class="lemma theorem-like" id="lemma-adjoint-preserves-jordan-decomposition"><h6 class="heading">
<span class="type">Lemma</span><span class="space"> </span><span class="codenumber">3.15</span><span class="period">.</span>
</h6>
<p id="p-129">Let \(F\) be a field of characteristic zero. Let \(A\in\mathfrak{gl}(n,F)\) be any linear map and \(A=A_s+A_n\) its Jordan decomposition. Then \(\ad(A)=\ad(A_s)+\ad(A_n)\) is the Jordan decomposition of the map \(\ad(A)\colon \mathfrak{gl}(n,F)\to\mathfrak{gl}(n,F)\text{.}\)</p></article><article class="hiddenproof" id="proof-12"><a data-knowl="" class="id-ref original" data-refid="hk-proof-12"><h6 class="heading"><span class="type">Proof<span class="period">.</span></span></h6></a></article><div class="hidden-content tex2jax_ignore" id="hk-proof-12"><article class="hiddenproof"><p id="p-130">By Proposition 2.2.5 of <a class="xref" data-knowl="./knowl/deGraaf-2017-computation_with_linear_algebraic_groups.html" title="Bibliographic Entry 12: Computation with linear algebraic groups">[12]</a>, since the field \(F\) is perfect (as a field of characteristic zero), the adjoint map preserves both semisimplicity and nilpotency, so the map \(\ad(A_s)\) is semisimple and the map \(\ad(A_n)\) is nilpotent. Moreover, since the maps \(A_s\) and \(A_n\) commute, the Jacobi identity implies that the maps \(\ad(A_s)\) and \(\ad(A_n)\) also commute. The claim follows from the uniqueness of the Jordan decomposition.</p></article></div>
<p id="p-131">With the above results, we are able to conclude that if the semisimple parts of \(A_i\) and \(A_i+A_j\) are contained in \(\mathfrak{t}\) for all basis elements \(A_i\text{,}\) then the torus \(\mathfrak{t}\) in step <a class="xref" data-knowl="./knowl/maxalg-6-nonnilpotent-element.html" title="Item 6">6</a> of <a class="xref" data-knowl="./knowl/algorithm-maximal-grading.html" title="Algorithm 3.12: Maximal grading">Algorithm 3.12</a> is maximal. First, by step <a class="xref" data-knowl="./knowl/maxalg-5-ad-kernel.html" title="Item 5">5</a> we have \(\mathfrak{t}=\ker(\ad)\) for the restricted adjoint representation \(\ad\colon C(\mathfrak{t})\to \bigoplus_{\lambda}\mathfrak{gl}(\mathfrak{gl}(V_\lambda))\) defined in step <a class="xref" data-knowl="./knowl/maxalg-4-ad-rep.html" title="Item 4">4</a>. Then for any \(A\in C(\mathfrak{t})\) by <a class="xref" data-knowl="./knowl/lemma-adjoint-preserves-jordan-decomposition.html" title="Lemma 3.15">Lemma 3.15</a> we find that \(A_s\in\mathfrak{t}\) if and only if \(\ad(A)=\ad(A_n)\text{,}\) that is, if and only if \(\ad(A)\) is nilpotent. By <a class="xref" data-knowl="./knowl/lemma-nonnilpotent-element.html" title="Lemma 3.14">Lemma 3.14</a>, if all \(\ad(A_i)\) and \(\ad(A_i+A_j)\) are nilpotent, then \(\ad(A)\) is nilpotent for all \(A\in C(\mathfrak{t})\text{.}\) Hence \(A_s\in\mathfrak{t}\) for all \(A\in C(\mathfrak{t})\text{.}\) In other words, no semisimple element \(A_s\in C(\mathfrak{t})\setminus\mathfrak{t}\) exists, so \(\mathfrak{t}\) is maximal.</p>
<p id="p-132">The final part of <a class="xref" data-knowl="./knowl/algorithm-maximal-grading.html" title="Algorithm 3.12: Maximal grading">Algorithm 3.12</a> is step <a class="xref" data-knowl="./knowl/maxalg-7-zk-indexing.html" title="Item 7">7</a>, where we replace the indexing by eigenvalues of the derivations of \(\mathfrak{t}\) with indexing over some \(\mathbb{Z}^k\) given by the universal realization. The precise method was described earlier in <a class="xref" data-knowl="./knowl/algorithm-integer-vector-grading.html" title="Algorithm 2.13: Universal realization">Algorithm 2.13</a>. Since the construction of the first six steps of <a class="xref" data-knowl="./knowl/algorithm-maximal-grading.html" title="Algorithm 3.12: Maximal grading">Algorithm 3.12</a> leads to a maximal torus of \(\der(\mathfrak{g})\text{,}\) by <a class="xref" data-knowl="./knowl/def-maximal-grading.html" title="Definition 2.21">Definition 2.21</a> the output is a maximal grading of \(\mathfrak{g}\text{.}\)</p>
<article class="remark remark-like" id="remark-non-algebraically-closed-fields"><h6 class="heading">
<span class="type">Remark</span><span class="space"> </span><span class="codenumber">3.16</span><span class="period">.</span>
</h6>
<p id="p-133">The only part where we use the assumption that the base field is algebraically closed is in step <a class="xref" data-knowl="./knowl/maxalg-6-nonnilpotent-element.html" title="Item 6">6</a>. The significance of the assumption is that the Jordan decomposition and Proposition 2.6.11 of <a class="xref" data-knowl="./knowl/deGraaf-2017-computation_with_linear_algebraic_groups.html" title="Bibliographic Entry 12: Computation with linear algebraic groups">[12]</a> give us an efficient method to construct semisimple elements in \(C(\mathfrak{t})\setminus\mathfrak{t}\text{.}\)</p>
<p id="p-134">If the base field is not algebraically closed, we need to explicitly require that the constructed elements of \(C(\mathfrak{t})\setminus\mathfrak{t}\) are diagonalizable. The subset of diagonalizable elements of \(C(\mathfrak{t})\setminus\mathfrak{t}\) is a semialgebraic set, and constructions to extract points from such sets exist, see for instance Section 13 of <a class="xref" data-knowl="./knowl/Basu-Pollack-Roy-2006-algorithms-in-real-algebraic-geometry.html" title="Bibliographic Entry 1: Algorithms in real algebraic geometry">[1]</a> on the existential theory of the reals. The problem is that these methods are practical only in low dimensions, and the construction would be needed in dimension \(\dim\mathfrak{gl}(\mathfrak{g})=\dim(\mathfrak{g})^2\text{.}\) For Lie algebras defined over finite fields, more efficient randomized algorithms to find split tori exist, see <a class="xref" data-knowl="./knowl/Cohen-Murray-2009_algorith_for_langs_theorem.html" title="Bibliographic Entry 5: An algorithm for Lang's Theorem">[5]</a> and <a class="xref" data-knowl="./knowl/Roozemond-2013-split_maximal_tori.html" title="Bibliographic Entry 27: Computing split maximal toral subalgebras of Lie algebras over fields of small characteristic">[27]</a>.</p></article></section></section></div></main>
</div>
</body>
</html>
