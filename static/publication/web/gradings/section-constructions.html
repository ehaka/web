<!DOCTYPE html>
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*       on 2021-06-29T12:15:03+02:00       *-->
<!--*   A recent stable commit (2020-08-09):   *-->
<!--* 98f21740783f166a773df4dc83cab5293ab63a4a *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<html lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Constructions</title>
<meta name="Keywords" content="Authored in PreTeXt">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script>window.MathJax = {
  tex: {
    inlineMath: [['\\(','\\)']],
    tags: "none",
    useLabelIds: true,
    tagSide: "right",
    tagIndent: ".8em",
    packages: {'[+]': ['base', 'extpfeil', 'ams', 'amscd', 'newcommand', 'knowl']}
  },
  options: {
    ignoreHtmlClass: "tex2jax_ignore",
    processHtmlClass: "has_am",
  },
  chtml: {
    scale: 0.88,
    mtextInheritFont: true
  },
  loader: {
    load: ['input/asciimath', '[tex]/extpfeil', '[tex]/amscd', '[tex]/newcommand', '[pretext]/mathjaxknowl3.js'],
    paths: {pretext: "https://pretextbook.org/js/lib"},
  },
};
</script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><script xmlns:svg="http://www.w3.org/2000/svg" src="https://pretextbook.org/js/lib/jquery.min.js"></script><script xmlns:svg="http://www.w3.org/2000/svg" src="https://pretextbook.org/js/lib/jquery.sticky.js"></script><script xmlns:svg="http://www.w3.org/2000/svg" src="https://pretextbook.org/js/lib/jquery.espy.min.js"></script><script xmlns:svg="http://www.w3.org/2000/svg" src="https://pretextbook.org/js/0.13/pretext.js"></script><script xmlns:svg="http://www.w3.org/2000/svg" src="https://pretextbook.org/js/0.13/pretext_add_on.js"></script><script xmlns:svg="http://www.w3.org/2000/svg" src="https://pretextbook.org/js/lib/knowl.js"></script><!--knowl.js code controls Sage Cells within knowls--><script xmlns:svg="http://www.w3.org/2000/svg">sagecellEvalName='Evaluate (Sage)';
</script><link xmlns:svg="http://www.w3.org/2000/svg" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400italic,600,600italic" rel="stylesheet" type="text/css">
<link xmlns:svg="http://www.w3.org/2000/svg" href="https://fonts.googleapis.com/css?family=Inconsolata:400,700&amp;subset=latin,latin-ext" rel="stylesheet" type="text/css">
<link xmlns:svg="http://www.w3.org/2000/svg" href="https://pretextbook.org/css/0.31/pretext.css" rel="stylesheet" type="text/css">
<link xmlns:svg="http://www.w3.org/2000/svg" href="https://pretextbook.org/css/0.31/pretext_add_on.css" rel="stylesheet" type="text/css">
<link xmlns:svg="http://www.w3.org/2000/svg" href="https://pretextbook.org/css/0.31/banner_default.css" rel="stylesheet" type="text/css">
<link xmlns:svg="http://www.w3.org/2000/svg" href="https://pretextbook.org/css/0.31/toc_default.css" rel="stylesheet" type="text/css">
<link xmlns:svg="http://www.w3.org/2000/svg" href="https://pretextbook.org/css/0.31/knowls_default.css" rel="stylesheet" type="text/css">
<link xmlns:svg="http://www.w3.org/2000/svg" href="https://pretextbook.org/css/0.31/style_default.css" rel="stylesheet" type="text/css">
<link xmlns:svg="http://www.w3.org/2000/svg" href="https://pretextbook.org/css/0.31/colors_default.css" rel="stylesheet" type="text/css">
<link xmlns:svg="http://www.w3.org/2000/svg" href="https://pretextbook.org/css/0.31/setcolors.css" rel="stylesheet" type="text/css">
<!-- 2019-10-12: Temporary - CSS file for experiments with styling --><link xmlns:svg="http://www.w3.org/2000/svg" href="developer.css" rel="stylesheet" type="text/css">
</head>
<body id="gradings" class="mathbook-article has-toc has-sidebar-left">
<a class="assistive" href="#content">Skip to main content</a><div xmlns:svg="http://www.w3.org/2000/svg" id="latex-macros" class="hidden-content" style="display:none">\(\newcommand{\abs}[1]{\left\lvert#1\right\rvert}
\newcommand{\restr}[2]{\left.#1\right\vert_{#2}}
\newcommand{\der}{\operatorname{der}}
\newcommand{\Aut}{\operatorname{Aut}}
\newcommand{\ad}{\operatorname{ad}}
\newcommand{\Ad}{\operatorname{Ad}}
\newcommand{\positiveset}{\mathbf{A}_+}
\newcommand{\norm}[1]{\left\lVert #1 \right\rVert}
\newcommand{\braket}[1]{\left\langle #1 \right\rangle}
\newcommand{\lt}{&lt;}
\newcommand{\gt}{&gt;}
\newcommand{\amp}{&amp;}
\)</div>
<header id="masthead" class="smallbuttons"><div class="banner"><div class="container">
<a id="logo-link" href=""></a><div class="title-container">
<h1 class="heading"><a href="gradings.html"><span class="title">Gradings for nilpotent Lie algebras</span></a></h1>
<p class="byline">Eero Hakavuori, Ville Kivioja, Terhi Moisala, Francesca Tripaldi</p>
</div>
</div></div>
<nav xmlns:svg="http://www.w3.org/2000/svg" id="primary-navbar" class="navbar"><div class="container">
<div class="navbar-top-buttons">
<button class="sidebar-left-toggle-button button active" aria-label="Show or hide table of contents sidebar">Contents</button><div class="tree-nav toolbar toolbar-divisor-3"><span class="threebuttons"><a id="previousbutton" class="previous-button toolbar-item button" href="section-preliminaries.html" title="Previous">Prev</a><a id="upbutton" class="up-button button toolbar-item" href="gradings.html" title="Up">Up</a><a id="nextbutton" class="next-button button toolbar-item" href="section-applications.html" title="Next">Next</a></span></div>
</div>
<div class="navbar-bottom-buttons toolbar toolbar-divisor-4">
<button class="sidebar-left-toggle-button button toolbar-item active">Contents</button><a class="previous-button toolbar-item button" href="section-preliminaries.html" title="Previous">Prev</a><a class="up-button button toolbar-item" href="gradings.html" title="Up">Up</a><a class="next-button button toolbar-item" href="section-applications.html" title="Next">Next</a>
</div>
</div></nav></header><div class="page">
<div xmlns:svg="http://www.w3.org/2000/svg" id="sidebar-left" class="sidebar" role="navigation"><div class="sidebar-content">
<nav id="toc"><ul>
<li class="link frontmatter">
<a href="frontmatter-1.html" data-scroll="frontmatter-1"><span class="title">Front Matter</span></a><ul><li><a href="acknowledgement-1.html" data-scroll="acknowledgement-1">Acknowledgements</a></li></ul>
</li>
<li class="link">
<a href="section-introduction.html" data-scroll="section-introduction"><span class="codenumber">1</span> <span class="title">Introduction</span></a><ul>
<li><a href="section-introduction.html#subsection-1" data-scroll="subsection-1">Overview</a></li>
<li><a href="section-introduction.html#subsection-2" data-scroll="subsection-2">Implemented algorithms and applications</a></li>
<li><a href="section-introduction.html#subsection-3" data-scroll="subsection-3">Structure of the paper</a></li>
</ul>
</li>
<li class="link">
<a href="section-preliminaries.html" data-scroll="section-preliminaries"><span class="codenumber">2</span> <span class="title">Preliminaries</span></a><ul>
<li><a href="section-preliminaries.html#ssec-base-fields" data-scroll="ssec-base-fields">On base fields</a></li>
<li><a href="section-preliminaries.html#ssec-gradings-and-equivalences" data-scroll="ssec-gradings-and-equivalences">Gradings and equivalences</a></li>
<li><a href="section-preliminaries.html#ssec-univ-gradings" data-scroll="ssec-univ-gradings">Universal realizations</a></li>
<li><a href="section-preliminaries.html#sec-gradings-by-tori" data-scroll="sec-gradings-by-tori">Gradings induced by tori</a></li>
<li><a href="section-preliminaries.html#section-maximal-gradings" data-scroll="section-maximal-gradings">Maximal gradings</a></li>
</ul>
</li>
<li class="link active">
<a href="section-constructions.html" data-scroll="section-constructions"><span class="codenumber">3</span> <span class="title">Constructions</span></a><ul>
<li><a href="section-constructions.html#subsection-torsion-free" data-scroll="subsection-torsion-free">Enumeration of torsion-free gradings</a></li>
<li><a href="section-constructions.html#section-stratifications" data-scroll="section-stratifications">Stratifications</a></li>
<li><a href="section-constructions.html#sssec-pos-gradings" data-scroll="sssec-pos-gradings">Positive gradings</a></li>
<li><a href="section-constructions.html#section-maximal-construction" data-scroll="section-maximal-construction">Maximal gradings</a></li>
</ul>
</li>
<li class="link">
<a href="section-applications.html" data-scroll="section-applications"><span class="codenumber">4</span> <span class="title">Applications</span></a><ul>
<li><a href="section-applications.html#applications-structure" data-scroll="applications-structure">Structure from maximal gradings</a></li>
<li><a href="section-applications.html#applications-classification" data-scroll="applications-classification">Classification of gradings in low dimension</a></li>
<li><a href="section-applications.html#applications-heintze" data-scroll="applications-heintze">Enumerating Heintze groups</a></li>
<li><a href="section-applications.html#applications-lpq" data-scroll="applications-lpq">Bounds for non-vanishing \(\ell^{q,p}\) cohomology</a></li>
</ul>
</li>
<li class="link backmatter"><a href="backmatter-1.html" data-scroll="backmatter-1"><span class="title">Back Matter</span></a></li>
<li class="link">
<a href="appendix-classification.html" data-scroll="appendix-classification"><span class="codenumber">A</span> <span class="title">Complete classification in low dimension</span></a><ul>
<li><a href="appendix-classification.html#classification-overview" data-scroll="classification-overview">Overview</a></li>
<li><a href="classification-dim2.html">Dimension 2</a></li>
<li><a href="classification-dim3.html">Dimension 3</a></li>
<li><a href="classification-dim4.html">Dimension 4</a></li>
<li><a href="classification-dim5.html">Dimension 5</a></li>
<li><a href="classification-dim6.html">Dimension 6</a></li>
<li><a href="classification-dim7.html">Dimension 7</a></li>
</ul>
</li>
<li class="link"><a href="appendix-2.html" data-scroll="appendix-2"><span class="codenumber">B</span> <span class="title">Notation</span></a></li>
<li class="link"><a href="section-references.html" data-scroll="section-references"><span class="title">References</span></a></li>
</ul></nav><div class="extras"><nav><a class="mathbook-link" href="https://pretextbook.org">Authored in PreTeXt</a><a href="https://www.mathjax.org"><img title="Powered by MathJax" src="https://www.mathjax.org/badge/badge.gif" alt="Powered by MathJax"></a></nav></div>
</div></div>
<main class="main"><div id="content" class="pretext-content"><section xmlns:svg="http://www.w3.org/2000/svg" class="section" id="section-constructions"><h2 class="heading hide-type">
<span class="type">Section</span> <span class="codenumber">3</span> <span class="title">Constructions</span>
</h2>
<section class="subsection" id="subsection-torsion-free"><h3 class="heading hide-type">
<span class="type">Subsection</span> <span class="codenumber">3.1</span> <span class="title">Enumeration of torsion-free gradings</span>
</h3>
<p id="p-79">Following the method suggested in Section 3.7 of <a class="xref" data-knowl="./knowl/Kochetov-2009-gradings_on_simple_lie_algebras_survey.html" title="Bibliographic Entry 23: Gradings on finite-dimensional simple Lie algebras">[23]</a>, we now give a simple way to enumerate a complete (and finite) set of <a class="xref" data-knowl="./knowl/def-universal-realization.html" title="Definition 2.8">universal realizations</a> of <a class="xref" data-knowl="./knowl/def-grading.html" title="Definition 2.2">gradings</a> of a Lie algebra using the <a class="xref" data-knowl="./knowl/def-maximal-grading.html" title="Definition 2.17">maximal grading</a>.</p>
<p id="p-80">For the rest of this section, let \(\mathfrak g\) be a Lie algebra and let \(\mathcal W : \mathfrak g = \bigoplus_{n\in \mathbb{Z}^k}W_n \) be a <a class="xref" data-knowl="./knowl/def-maximal-grading.html" title="Definition 2.17">maximal grading</a>  of \(\mathfrak g\) with <a class="xref" data-knowl="./knowl/def-grading.html" title="Definition 2.2">weights</a> \(\Omega\text{.}\) Denote by \(\Omega-\Omega\) the difference set \(\Omega- \Omega = \{n-m \,\mid\, n,m\in \Omega\}\text{.}\) For a subset \(I \subset \Omega-\Omega \text{,}\) let</p>
<div class="displaymath">
\begin{equation*}
\pi_I \colon \mathbb{Z}^k \to \mathbb{Z}^k/\langle I\rangle
\end{equation*}
</div>
<p class="continuation">be the canonical projection. We define the finite set</p>
<div class="displaymath">
\begin{equation}
\Gamma = \{{(\pi_I)_*\mathcal W}\mid I \subset \Omega - \Omega, \;\mathbb{Z}^k/\langle I\rangle\text{ is torsion-free} \}.\label{eq-Gamma}\tag{3.1}
\end{equation}
</div>
<article class="proposition theorem-like" id="prop-Quot-gradings-are-everything"><h6 class="heading">
<span class="type">Proposition</span><span class="space"> </span><span class="codenumber">3.1</span><span class="period">.</span>
</h6>
<p id="p-81">The set \(\Gamma\) is, up to <a class="xref" data-knowl="./knowl/def-equivalent-group-gradings.html" title="Definition 2.5">equivalence</a>, a complete set of <a class="xref" data-knowl="./knowl/def-universal-realization.html" title="Definition 2.8">universal realizations</a> of <a class="xref" data-knowl="./knowl/def-torsion-free-grading.html" title="Definition 2.3">torsion-free gradings</a>  of \(\mathfrak g\text{.}\)</p></article><article class="hiddenproof" id="proof-8"><a data-knowl="" class="id-ref proof-knowl original" data-refid="hk-proof-8"><h6 class="heading"><span class="type">Proof<span class="period">.</span></span></h6></a></article><div class="hidden-content tex2jax_ignore" id="hk-proof-8"><article class="hiddenproof"><p id="p-82">Let \(\mathcal{V}\) be the universal realization of some torsion-free grading. Due to <a class="xref" data-knowl="./knowl/lemma-universal-realization-Zk.html" title="Lemma 2.10">Lemma 2.10</a>, the <a class="xref" data-knowl="./knowl/def-grading.html" title="Definition 2.2">grading group</a> of \(\mathcal V\) is some \(\mathbb{Z}^m\text{.}\) By <a class="xref" data-knowl="./knowl/prop-max-grading.html" title="Proposition 2.19">Proposition 2.19</a>, there exists a homomorphism \(f\colon \mathbb{Z}^k\to \mathbb{Z}^m \) and an automorphism \(\Phi \in \Aut(\mathfrak g)\) such that \(\mathcal V= f_*\Phi(\mathcal W) \text{.}\) Let</p>
<div class="displaymath">
\begin{equation*}
I = \ker(f)\cap (\Omega-\Omega).
\end{equation*}
</div>
<p class="continuation">We are going to show that \(\mathcal V' = (\pi_I)_*(\mathcal W) \) is equivalent to \(\mathcal{V}\text{.}\) Then, a posteriori, \(\mathbb{Z}^k/\langle I\rangle\) is torsion-free and we have \(\mathcal V' \in \Gamma\text{,}\) proving the claim.</p>
<p id="p-83">First, since \(\ker(\pi_I) = \langle I\rangle \subseteq \ker(f)\text{,}\) by the universal property of quotients there exists a unique homomorphism \(\phi \colon  \mathbb{Z}^k/\langle I\rangle  \to \mathbb{Z}^m \) such that \(f = \phi \circ \pi_I\text{.}\) In particular,</p>
<div class="displaymath">
\begin{equation*}
\mathcal V = f_*\Phi(\mathcal W) = \phi_*(\pi_I)_*\Phi(\mathcal W) = \phi_*\Phi(\mathcal V')\text{,}
\end{equation*}
</div>
<p class="continuation">so \(\mathcal V\) is a push-forward grading of \(\mathcal V'\text{.}\)</p>
<p id="p-84">Secondly, since also \(\ker(f)\cap (\Omega-\Omega) = I \subseteq \ker(\pi_I)\cap (\Omega-\Omega) \text{,}\) we deduce that \(\mathcal V \) and \(\Phi(\mathcal V')\) are realizations of the same grading. Since \(\mathcal V\) is a universal realization, it follows that \(\Phi(\mathcal V')\) is a <a class="xref" data-knowl="./knowl/def-push-forward-grading.html" title="Definition 2.4">push-forward</a>  grading of \(\mathcal V\text{.}\) Consequently, \(\mathcal V'\) is a push-forward grading of \(\mathcal V\text{.}\) Since the grading group of a universal realization is generated by the weights, we get that the gradings \(\mathcal V\) and \(\mathcal V'\) are equivalent  by <a class="xref" data-knowl="./knowl/lemma-pf-with-generating-weights.html" title="Lemma 2.6">Lemma 2.6</a>, as wanted.</p></article></div>
<p id="p-85">Notice that some of the \(\mathbb{Z}^k/\langle I\rangle\)-gradings in \(\Gamma\) are typically equivalent to each other. From the classification point of view, a more challenging task is to determine the equivalence classes once the set \(\Gamma\) is obtained. In low dimensions, naive methods are enough to separate non-equivalent gradings, and for equivalent ones the connecting automorphism can be found rather easily.</p>
<p id="p-86">In <a class="xref" data-knowl="./knowl/software-lie_algebra_gradings.html" title="Bibliographic Entry 20: ehaka/lie-algebra-gradings: v1.1">[20]</a> we give a representative from each equivalence class in \(\Gamma\) for every 6 dimensional nilpotent Lie algebra over \(\mathbb{C}\) and for an extensive class of 7 dimensional Lie algebras over \(\mathbb{C}\text{.}\) The results and the methods for distinguishing the equivalence classes of the obtained gradings are described in more detail in <a href="section-applications.html#applications-classification" class="internal" title="Subsection 4.2: Classification of gradings in low dimension">Subsection 4.2</a>.</p></section><section class="subsection" id="section-stratifications"><h3 class="heading hide-type">
<span class="type">Subsection</span> <span class="codenumber">3.2</span> <span class="title">Stratifications</span>
</h3>
<article class="definition definition-like" id="def-stratification"><h6 class="heading">
<span class="type">Definition</span><span class="space"> </span><span class="codenumber">3.2</span><span class="period">.</span>
</h6>
<p id="p-87">A <dfn class="terminology">stratification</dfn> (a.k.a. <dfn class="terminology">Carnot grading</dfn>) is a <a class="xref" data-knowl="./knowl/def-grading.html" title="Definition 2.2">\(\mathbb{Z}\)-grading</a> \(\mathfrak{g}=\bigoplus_{n\in\mathbb{Z}}V_n\) such that \(V_1\) generates \(\mathfrak{g}\) as a Lie algebra. A Lie algebra \(\mathfrak{g}\) is <dfn class="terminology">stratifiable</dfn> if it admits a stratification.</p></article><p id="p-88">In this section we present the linear problem of constructing a stratification for a Lie algebra (or determining that one does not exist). The method is based on Lemma 3.10 of <a class="xref" data-knowl="./knowl/Cornulier-2016-gradings.html" title="Bibliographic Entry 6: Gradings on Lie algebras, systolic growth, and cohopfian properties of nilpotent groups">[6]</a>, which gives the following characterization of stratifiable Lie algebras:</p>
<article class="lemma theorem-like" id="lemma-stratification-by-derivation"><h6 class="heading">
<span class="type">Lemma</span><span class="space"> </span><span class="codenumber">3.3</span><span class="period">.</span>
</h6>
<p id="p-89">A nilpotent Lie algebra \(\mathfrak{g}\) is <a class="xref" data-knowl="./knowl/def-stratification.html" title="Definition 3.2">stratifiable</a> if and only if there exists a derivation \(\delta\colon\mathfrak{g}\to\mathfrak{g}\) such that the induced map \(\mathfrak{g}/[\mathfrak{g},\mathfrak{g}]\to \mathfrak{g}/[\mathfrak{g},\mathfrak{g}]\) is the identity map. Moreover, a stratification is given by the <a class="xref" data-knowl="./knowl/def-grading.html" title="Definition 2.2">layers</a> \(V_i=\ker (\delta-i)\text{.}\)</p></article><p id="p-90">The condition of <a class="xref" data-knowl="./knowl/lemma-stratification-by-derivation.html" title="Lemma 3.3">Lemma 3.3</a> is straightforward to check in a basis <a class="xref" data-knowl="./knowl/def-basis-adapted-to-lcs.html" title="Definition 3.4">adapted to the lower central series</a>.</p>
<article class="definition definition-like" id="def-basis-adapted-to-lcs"><h6 class="heading">
<span class="type">Definition</span><span class="space"> </span><span class="codenumber">3.4</span><span class="period">.</span>
</h6>
<p id="p-91">The lower central series of a Lie algebra \(\mathfrak{g}\) is the decreasing sequence of subspaces</p>
<div class="displaymath">
\begin{equation*}
\mathfrak{g}=\mathfrak{g}^{(1)}\supset \mathfrak{g}^{(2)}\supset \mathfrak{g}^{(3)}\supset\cdots\text{,}
\end{equation*}
</div>
<p class="continuation">where \(\mathfrak{g}^{(i+1)} = [\mathfrak{g},\mathfrak{g}^{(i)}]\text{.}\) A basis \(X_1,\dots,X_n\) of a Lie algebra \(\mathfrak{g}\) is <dfn class="terminology">adapted to the lower central series</dfn> if for every non-zero \(\mathfrak{g}^{(i)}\) there exists an index \(n_i\in\mathbb{N}\) such that \(X_{n_i},\dots,X_n\) is a basis of \(\mathfrak{g}^{(i)}\text{.}\) The <dfn class="terminology">degree</dfn> of the basis element \(X_i\) is the integer \(w_i=\max\{j\in\mathbb{N}: X_i\in\mathfrak{g}^{(j)}\}\text{.}\)</p></article><article class="proposition theorem-like" id="prop-stratification-explicit-leibniz"><h6 class="heading">
<span class="type">Proposition</span><span class="space"> </span><span class="codenumber">3.5</span><span class="period">.</span>
</h6>
<p id="p-92">Let \(X_1,\ldots,X_n\) be a basis <a class="xref" data-knowl="./knowl/def-basis-adapted-to-lcs.html" title="Definition 3.4">adapted to the lower central series</a> of a nilpotent Lie algebra \(\mathfrak{g}\) defined over a field \(F\text{.}\) Let \(w_1,\ldots,w_n\) be the <a class="xref" data-knowl="./knowl/def-basis-adapted-to-lcs.html" title="Definition 3.4">degrees</a>  of the basis elements and let \(c_{ij}^k\in F\) be the <a class="xref" data-knowl="./knowl/par-structure-coefficients.html" title="Paragraph">structure coefficients</a> in the basis. A linear map \(\delta\colon\mathfrak{g}\to\mathfrak{g}\) is a derivation that restricts to the identity on \(\mathfrak{g}/[\mathfrak{g},\mathfrak{g}]\) if and only if</p>
<div class="displaymath">
\begin{equation}
\delta(X_i) = w_iX_i + \sum_{w_j\gt w_i}a_{ij}X_j\label{eq-derivation-in-lcs-basis}\tag{3.2}
\end{equation}
</div>
<p class="continuation">such that, for each triple of indices \(i,j,k\) such that \(w_k\gt w_i+w_j\text{,}\) the coefficients \(a_{ij}\in F\) satisfy the linear equation</p>
<div class="displaymath">
\begin{align}
c_{ij}^k(w_k-w_i-w_j) = \amp\sum_{w_i\lt w_h\leq w_k-w_j}a_{ih}c_{hj}^k+\sum_{w_j\lt w_h\leq w_k-w_i}a_{jh}c_{ih}^k\label{eq-stratifying-leibniz-condition}\tag{3.3}\\
-\amp\sum_{w_i+w_j\leq w_h\lt w_k}c_{ij}^ha_{hk}\text{.}\notag
\end{align}
</div></article><article class="hiddenproof" id="proof-9"><a data-knowl="" class="id-ref proof-knowl original" data-refid="hk-proof-9"><h6 class="heading"><span class="type">Proof<span class="period">.</span></span></h6></a></article><div class="hidden-content tex2jax_ignore" id="hk-proof-9"><article class="hiddenproof"><p id="p-93">If \(\delta\colon\mathfrak{g}\to\mathfrak{g}\) is a derivation that restricts to the identity on \(\mathfrak{g}/[\mathfrak{g},\mathfrak{g}]\text{,}\) then by <a class="xref" data-knowl="./knowl/lemma-stratification-by-derivation.html" title="Lemma 3.3">Lemma 3.3</a> \(\mathfrak{g}\) admits a <a class="xref" data-knowl="./knowl/def-stratification.html" title="Definition 3.2">stratification</a></p>
<div class="displaymath">
\begin{equation*}
\mathfrak{g}=V_1\oplus\dots\oplus V_s
\end{equation*}
</div>
<p class="continuation">such that \(\restr{\delta}{V_i} = i\cdot \operatorname{id}\text{.}\) Since the terms of the lower central series are given in terms of the stratification as \(\mathfrak{g}^{(i)}=V_i\oplus\dots\oplus V_s \text{,}\) it follows that \(\delta(Y)\in i\cdot Y+\mathfrak{g}^{(i+1)}\) for any \(Y\in\mathfrak{g}^{(i)}\text{.}\) That is, a derivation \(\delta\) restricting to the identity on \(\mathfrak{g}/[\mathfrak{g},\mathfrak{g}]\) is of the form <a class="xref" data-knowl="./knowl/eq-derivation-in-lcs-basis.html" title="Equation 3.2">(3.2)</a> for some coefficients \(a_{ij}\in F\text{.}\)</p>
<p id="p-94">It is then enough to show that <a class="xref" data-knowl="./knowl/eq-stratifying-leibniz-condition.html" title="Equation 3.3">(3.3)</a> is equivalent to the Leibniz rule</p>
<div class="displaymath">
\begin{equation*}
\delta([X_i,X_j]) = [\delta(X_i),X_j]+[X_i,\delta(X_j)],\quad \forall i,j\in\{1,\ldots,n\}\text{.}
\end{equation*}
</div>
<p class="continuation">Indeed, this would prove that a linear map defined by <a class="xref" data-knowl="./knowl/eq-derivation-in-lcs-basis.html" title="Equation 3.2">(3.2)</a> is a derivation if and only if the coefficients \(a_{ij}\) satisfy the linear system <a class="xref" data-knowl="./knowl/eq-stratifying-leibniz-condition.html" title="Equation 3.3">(3.3)</a>.</p>
<p id="p-95">Since the basis \(X_i\) is adapted to the lower central series, only the structure coefficients with large enough degrees are non-zero, i.e., we have</p>
<div class="displaymath">
\begin{equation}
[X_i,X_j] = \sum_{w_k\geq w_i+w_j}c_{ij}^kX_k\text{.}\label{eq-lcs-basis-structure-coefficients}\tag{3.4}
\end{equation}
</div>
<p class="continuation">By direct computation using <a class="xref" data-knowl="./knowl/eq-derivation-in-lcs-basis.html" title="Equation 3.2">(3.2)</a> and <a class="xref" data-knowl="./knowl/eq-lcs-basis-structure-coefficients.html" title="Equation 3.4">(3.4)</a> we get the expressions</p>
<div class="displaymath">
\begin{align*}
[\delta(X_i),X_j] \amp =  \sum_{w_k\geq w_i+w_j}c_{ij}^kw_iX_k + \sum_{w_h\gt w_i}\sum_{w_k\geq w_h+w_j}a_{ih}c_{hj}^kX_k\\
[X_i,\delta(X_j)] \amp = \sum_{w_k\geq w_i+w_j}c_{ij}^kw_jX_k + \sum_{w_h\gt w_j}\sum_{w_k\geq w_i+w_h}a_{jh}c_{ih}^kX_k\\
\delta([X_i,X_j]) \amp = \sum_{w_k\geq w_i+w_j}c_{ij}^kw_kX_k + \sum_{w_h\geq w_i+w_j}\sum_{w_k\gt w_h}c_{ij}^ha_{hk}X_k
\end{align*}
</div>
<p class="continuation">Denoting \(\sum_k B_{ij}^kX_k = \delta([X_i,X_j])-[\delta(X_i),X_j]-[X_i,\delta(X_j)]\text{,}\) we find that the equation \(B_{ij}^k=0\) is up to reorganizing terms equivalent to <a class="xref" data-knowl="./knowl/eq-stratifying-leibniz-condition.html" title="Equation 3.3">(3.3)</a>.</p>
<p id="p-96">Finally, we observe that when \(w_k\leq w_i+w_j\text{,}\) the condition \(B_{ij}^k=0\) is automatically satisfied: for \(w_k\lt w_i+w_j\) all of the sums are empty, and for \(w_k=w_i+w_j\text{,}\) the only remaining terms from the sums cancel out as</p>
<div class="displaymath">
\begin{equation*}
B_{ij}^k = c_{ij}^kw_k-c_{ij}^kw_i-c_{ij}^kw_j=0\text{.}
\end{equation*}
</div></article></div>
<p id="p-97">The concrete criterion of <a class="xref" data-knowl="./knowl/prop-stratification-explicit-leibniz.html" title="Proposition 3.5">Proposition 3.5</a> provides the algorithm to construct a stratification.</p>
<article class="algorithm theorem-like" id="algorithm-stratification"><h6 class="heading">
<span class="type">Algorithm</span><span class="space"> </span><span class="codenumber">3.6</span><span class="period">.</span><span class="space"> </span><span class="title">Stratification.</span>
</h6>
<p id="p-98">Input: A nilpotent Lie algebra \(\mathfrak{g}\text{.}\) Output: A <a class="xref" data-knowl="./knowl/def-stratification.html" title="Definition 3.2">stratification</a> of \(\mathfrak{g}\) or the non-existence of one.</p>
<ol class="decimal">
<li id="alg-stratification-1-lcs">Construct a basis \(X_1,\ldots,X_n\) <a class="xref" data-knowl="./knowl/def-basis-adapted-to-lcs.html" title="Definition 3.4">adapted to the lower central series</a>.</li>
<li id="alg-stratification-2-leibniz">Find a derivation \(\delta\) as in <a class="xref" data-knowl="./knowl/eq-derivation-in-lcs-basis.html" title="Equation 3.2">(3.2)</a> by solving the linear system <a class="xref" data-knowl="./knowl/eq-stratifying-leibniz-condition.html" title="Equation 3.3">(3.3)</a>. If the system has no solutions, then \(\mathfrak{g}\) is not <a class="xref" data-knowl="./knowl/def-stratification.html" title="Definition 3.2">stratifiable</a>.</li>
<li id="alg-stratification-3-layers">Return the stratification with the <a class="xref" data-knowl="./knowl/def-grading.html" title="Definition 2.2">layers</a> \(V_i=\ker (\delta-i)\text{.}\)</li>
</ol></article><article class="remark remark-like" id="remark-stratification-field-extension"><h6 class="heading">
<span class="type">Remark</span><span class="space"> </span><span class="codenumber">3.7</span><span class="period">.</span>
</h6>
<p id="p-99">By Theorem 1.4 of <a class="xref" data-knowl="./knowl/Cornulier-2016-gradings.html" title="Bibliographic Entry 6: Gradings on Lie algebras, systolic growth, and cohopfian properties of nilpotent groups">[6]</a>, the existence of a stratification for a Lie algebra is invariant under base field extensions, so in <a class="xref" data-knowl="./knowl/algorithm-stratification.html" title="Algorithm 3.6: Stratification">Algorithm 3.6</a>, it suffices to work within any field \(F\) that \(\mathfrak{g}\) is <a class="xref" data-knowl="./knowl/def-defined-over.html" title="Definition 2.1">defined over</a>.</p></article></section><section class="subsection" id="sssec-pos-gradings"><h3 class="heading hide-type">
<span class="type">Subsection</span> <span class="codenumber">3.3</span> <span class="title">Positive gradings</span>
</h3>
<article class="definition definition-like" id="def-positive-grading"><h6 class="heading">
<span class="type">Definition</span><span class="space"> </span><span class="codenumber">3.8</span><span class="period">.</span>
</h6>
<p id="p-100">An <a class="xref" data-knowl="./knowl/def-grading.html" title="Definition 2.2">\(\mathbb{R}\)-grading</a> \(\mathcal{V} \colon \mathfrak{g} = \bigoplus_{\alpha \in \mathbb{R}} V_\alpha \) is <dfn class="terminology">positive</dfn> if \(\alpha\gt 0\) for all the <a class="xref" data-knowl="./knowl/def-grading.html" title="Definition 2.2">weights</a> of \(\mathcal{V}\text{.}\) If such a grading exists for \(\mathfrak{g}\text{,}\) then \(\mathfrak{g}\) is said to be <dfn class="terminology">positively gradable</dfn>.</p></article><p id="p-101">In this section, we formulate and prove <a class="xref" data-knowl="./knowl/algorithm-positive-realization.html" title="Algorithm 3.9: Positive realization">Algorithm 3.9</a>. Using this algorithm one can decide whether a given grading of a Lie algebra admits a positive realization. If one starts with a Lie algebra with a known maximal grading, one is therefore able to answer the following questions:</p>
<ol class="lower-roman">
<li id="question-existence-of-positive-grading">Can the Lie algebra be equipped with a positive grading?</li>
<li id="question-enumeration-of-positive-gradings">Can one find in some sense all positive gradings of the Lie algebra?</li>
</ol>
<p id="p-102">The methods of this article to construct a maximal grading are guaranteed to work only when the Lie algebra is defined over an algebraically closed field, see <a href="section-constructions.html#section-maximal-construction" class="internal" title="Subsection 3.4: Maximal gradings">Subsection 3.4</a>. In this discussion, we shall assume we are given a Lie algebra and a maximal grading for it, but we are not assuming that the field of coefficients is algebraically closed. However, regarding question <a class="xref" data-knowl="./knowl/question-existence-of-positive-grading.html" title="Item i">i</a>, note that the existence of a positive grading for a given Lie algebra is invariant under extension of scalars by Theorem 1.4 of <a class="xref" data-knowl="./knowl/Cornulier-2016-gradings.html" title="Bibliographic Entry 6: Gradings on Lie algebras, systolic growth, and cohopfian properties of nilpotent groups">[6]</a> so we may as well work with the algebraic closure.</p>
<p id="p-103">To answer question <a class="xref" data-knowl="./knowl/question-existence-of-positive-grading.html" title="Item i">i</a>, we observe that a Lie algebra admits a positive grading if and only if its maximal grading admits a positive realization by <a class="xref" data-knowl="./knowl/prop-max-grading.html" title="Proposition 2.19">Proposition 2.19</a>. A maximal grading admits a positive realization exactly when the convex hull of its weights does not contain zero, see Proposition 3.22 of <a class="xref" data-knowl="./knowl/Cornulier-2016-gradings.html" title="Bibliographic Entry 6: Gradings on Lie algebras, systolic growth, and cohopfian properties of nilpotent groups">[6]</a>. To concretely find a positive realization, one may use <a class="xref" data-knowl="./knowl/algorithm-positive-realization.html" title="Algorithm 3.9: Positive realization">Algorithm 3.9</a>.</p>
<p id="p-104">Question <a class="xref" data-knowl="./knowl/question-enumeration-of-positive-gradings.html" title="Item ii">ii</a> admits two relevant interpretations. First, one may use the enumeration of universal realizations of gradings of the given Lie algebra, as done in <a href="section-constructions.html#subsection-torsion-free" class="internal" title="Subsection 3.1: Enumeration of torsion-free gradings">Subsection 3.1</a>, and using <a class="xref" data-knowl="./knowl/algorithm-positive-realization.html" title="Algorithm 3.9: Positive realization">Algorithm 3.9</a> construct their positive realizations when such realizations exist. The resulting list of positive gradings is complete in the sense that every positive grading of the given Lie algebra has the same layers as a grading on the list, up to a Lie algebra automorphism.</p>
<p id="p-105">Question <a class="xref" data-knowl="./knowl/question-enumeration-of-positive-gradings.html" title="Item ii">ii</a> may also be interpreted as finding a parametrization of the usually uncountable family of positive gradings. Let \(\mathcal W :\mathfrak{g}=\bigoplus_{n\in \mathbb{Z}^k}W_n\) be a <a class="xref" data-knowl="./knowl/def-maximal-grading.html" title="Definition 2.17">maximal grading</a> of our given Lie algebra \(\mathfrak g\) and let \(\Omega\) be the set of weights of \(\mathcal{W}\text{.}\) For any \(\mathbf{a}=(a_1,\ldots,a_k)\in\mathbb{R}^k\text{,}\) let \(\pi^{\mathbf a} \colon \mathbb{Z}^k \to \mathbb{R}\) be the projection given by \(\pi^{\mathbf a}(e_i)=a_i\) with \(e_i\) denoting the standard basis elements of \(\mathbb{Z}^k\text{.}\) Let</p>
<div class="displaymath">
\begin{equation}
\positiveset = \{\mathbf{a}\in\mathbb{R}^k: \pi^{\mathbf a}(n)\gt 0\,\forall n\in\Omega \}\text{.}\label{eq-positive-set}\tag{3.5}
\end{equation}
</div>
<p class="continuation">The <a class="xref" data-knowl="./knowl/def-push-forward-grading.html" title="Definition 2.4">push-forward grading</a> \(\pi^{\mathbf a}_*(\mathcal W)\) is a positive grading if and only if \(\mathbf{a}\in\positiveset\text{.}\) Every positive grading of \(\mathfrak{g}\) is equivalent to some grading \(\pi^{\mathbf a}_*(\mathcal W)\) and hence corresponds to an element of the set \(\positiveset\text{.}\) However, a pair of different elements of \(\positiveset\) may correspond to a pair of equivalent gradings.</p>
<p id="p-106">We next present and prove <a class="xref" data-knowl="./knowl/algorithm-positive-realization.html" title="Algorithm 3.9: Positive realization">Algorithm 3.9</a>. The idea behind the algorithm is rather simple: finding a positive realization can be seen as a linear programming problem. The purpose of the slightly cumbersome form of the linear programming problem in <a class="xref" data-knowl="./knowl/algorithm-positive-realization.html" title="Algorithm 3.9: Positive realization">Algorithm 3.9</a> is to guarantee that the weights of the positive realization are small. This method works well for problems in small dimensions, but does not scale well to large problems. If one does not care about the resulting positive weights, there is a simpler algorithm, see <a class="xref" data-knowl="./knowl/rmk-lightweight-positivity-algorithm.html" title="Remark 3.10">Remark 3.10</a>.</p>
<article class="algorithm theorem-like" id="algorithm-positive-realization"><h6 class="heading">
<span class="type">Algorithm</span><span class="space"> </span><span class="codenumber">3.9</span><span class="period">.</span><span class="space"> </span><span class="title">Positive realization.</span>
</h6>
<p id="p-107">Input: A <a class="xref" data-knowl="./knowl/def-torsion-free-grading.html" title="Definition 2.3">torsion-free grading</a> \(\mathcal{V}\) for a Lie algebra \(\mathfrak{g}\text{.}\) Output: A <a class="xref" data-knowl="./knowl/def-positive-grading.html" title="Definition 3.8">positive</a> <a class="xref" data-knowl="./knowl/def-realization.html" title="Definition 2.7"></a>integer realization of \(\mathcal{V}\) with the smallest possible maximal weight, if any positive realization exists.</p>
<ol class="decimal">
<li id="li-11">Compute the <a class="xref" data-knowl="./knowl/def-universal-realization.html" title="Definition 2.8">universal realization</a> \(\widetilde{\mathcal{V}}\) of \(\mathcal{V}\) using <a class="xref" data-knowl="./knowl/algorithm-integer-vector-grading.html" title="Algorithm 2.9: Universal realization">Algorithm 2.9</a>. Let \(\alpha_1,\ldots,\alpha_N \in \mathbb{Z}^k\) be the weights of \(\widetilde{\mathcal{V}}\text{.}\)</li>
<li id="alg-pos-apriori-bound">Compute<div class="displaymath">
\begin{equation*}
M = 1+\max\Big(\max_{i,j}\norm{\alpha_i-\alpha_j}_\infty,\max_i\norm{\alpha_i}_\infty\Big)
\end{equation*}
</div>and set \(C = (3+N2^{N+1})M^k\text{.}\)</li>
<li id="alg-pos-distinct-solution">Solve the integer linear programming problem<div class="displaymath">
\begin{align}
\text{Minimize}\amp\amp z\label{eq-pos-linprog-optimization}\tag{3.6}\\
\text{subject to}\amp\amp z\geq \braket{w,\alpha_i} \amp\geq 1,\amp\quad 1\amp\leq i\leq N\label{eq-pos-linprog-positivity}\tag{3.7}\\
\amp\amp\braket{w,\alpha_i-\alpha_j} \amp\geq b_{ij} -C(1-b_{ij}),\amp\quad 1\amp\leq i\lt j\leq N\label{eq-pos-linprog-disjoint1}\tag{3.8}\\
\amp\amp\braket{w,\alpha_i-\alpha_j} \amp\leq b_{ij}-1 + Cb_{ij},\amp\quad 1\amp\leq i\lt j\leq N\label{eq-pos-linprog-disjoint2}\tag{3.9}
\end{align}
</div>in the variables \(z\in\mathbb{Z}\text{,}\) \(w\in\mathbb{Z}^k\) and binary variables \(b_{ij}\in\{0,1\}\text{.}\) If no solution exists, then the grading \(\mathcal{V}\) does not have a positive realisation.</li>
<li id="alg-pos-pushforward">Let \(f\colon \mathbb{Z}^k\to\mathbb{Z}\) be the homomorphism \(f(\cdot)=\langle w,\cdot\rangle\text{.}\) Return the <a class="xref" data-knowl="./knowl/def-push-forward-grading.html" title="Definition 2.4">push-forward grading</a> \(f_*\widetilde{\mathcal{V}}\text{.}\)</li>
</ol></article><article class="hiddenproof" id="proof-10"><a data-knowl="" class="id-ref proof-knowl original" data-refid="hk-proof-10"><h6 class="heading"><span class="title">Proof of correctness.</span></h6></a></article><div class="hidden-content tex2jax_ignore" id="hk-proof-10"><article class="hiddenproof"><p id="p-108">If the grading \(\mathcal{V}\) has a positive realization, then it is a <a class="xref" data-knowl="./knowl/def-push-forward-grading.html" title="Definition 2.4">push-forward grading</a> of the universal realization by some homomorphism \(f\colon \mathbb{Z}^k\to\mathbb{R}\) satisfying the inequalities \(f(\alpha_i)\gt 0\) and \(f(\alpha_i)\neq f(\alpha_j)\) for all \(i\neq j\text{.}\) Since the inequalities all have integer coefficients, the existence of such a homomorphism is equivalent to the existence of a homomorphism \(f\colon \mathbb{Z}^k\to\mathbb{Z}\) with the same properties. We may always write such a homomorphism in the form \(f(\cdot)=\braket{w,\cdot}\) for some \(w\in\mathbb{Z}^k\text{.}\) To prove the correctness of the algorithm, we need to show that the linear programming problem <a class="xref" data-knowl="./knowl/eq-pos-linprog-optimization.html" title="Equation 3.6">(3.6)</a>–<a class="xref" data-knowl="./knowl/eq-pos-linprog-disjoint2.html" title="Equation 3.9">(3.9)</a> has a solution if and only if there exists \(w\in\mathbb{Z}^k\) such that</p>
<div class="displaymath">
\begin{align}
\braket{w,\alpha_i}\amp\geq 1\label{eq-positive}\tag{3.10}\\
\braket{w,\alpha_i-\alpha_j}\amp\neq 0\label{eq-disjoint}\tag{3.11}
\end{align}
</div>
<p class="continuation">and that this solution has the smallest possible \(\max_i \braket{w,\alpha_i}\text{.}\) Furthermore we claim, that if a suitable \(w\in\mathbb{Z}^k\) exists, then there also exists one with</p>
<div class="displaymath">
\begin{equation}
\abs{\braket{w,\alpha_i-\alpha_j}}\leq C\label{eq-bounded-abs-diff}\tag{3.12}
\end{equation}
</div>
<p class="continuation">where \(C\) is the constant defined in step <a class="xref" data-knowl="./knowl/alg-pos-apriori-bound.html" title="Item 2">2</a>. We prove this claim later.</p>
<p id="p-109">The smallest maximal weight property is equivalent to <a class="xref" data-knowl="./knowl/eq-pos-linprog-optimization.html" title="Equation 3.6">(3.6)</a> and the first half of <a class="xref" data-knowl="./knowl/eq-pos-linprog-positivity.html" title="Equation 3.7">(3.7)</a>, since a solution will necessarily satisfy \(z = \max_i \braket{w,\alpha_i}\text{.}\) The latter half of <a class="xref" data-knowl="./knowl/eq-pos-linprog-positivity.html" title="Equation 3.7">(3.7)</a> is exactly the condition <a class="xref" data-knowl="./knowl/eq-positive.html" title="Equation 3.10">(3.10)</a>. The inequalities <a class="xref" data-knowl="./knowl/eq-disjoint.html" title="Equation 3.11">(3.11)</a> and <a class="xref" data-knowl="./knowl/eq-bounded-abs-diff.html" title="Equation 3.12">(3.12)</a> are encoded in the inequalities <a class="xref" data-knowl="./knowl/eq-pos-linprog-disjoint1.html" title="Equation 3.8">(3.8)</a> and <a class="xref" data-knowl="./knowl/eq-pos-linprog-disjoint2.html" title="Equation 3.9">(3.9)</a> using the auxiliary binary variables \(b_{ij}\text{.}\) Indeed, if we have \(b_{ij}=0\text{,}\) then the inequalities reduce to</p>
<div class="displaymath">
\begin{equation*}
-C\leq \braket{w,\alpha_i-\alpha_j}\leq -1
\end{equation*}
</div>
<p class="continuation">and if \(b_{ij}=1\) then the inequalities reduce to</p>
<div class="displaymath">
\begin{equation*}
1\leq \braket{w,\alpha_i-\alpha_j}\leq C\text{.}
\end{equation*}
</div>
<p class="continuation">Therefore it remains to prove the claim about  the additional condition <a class="xref" data-knowl="./knowl/eq-bounded-abs-diff.html" title="Equation 3.12">(3.12)</a>.</p>
<p id="p-110">First we show that disregarding the other constraints, the system <a class="xref" data-knowl="./knowl/eq-positive.html" title="Equation 3.10">(3.10)</a> has a solution if and only if there exists a solution with \(\abs{\braket{w,\alpha_i}} \leq 1+N2^N\text{.}\) The normal form of the system <a class="xref" data-knowl="./knowl/eq-positive.html" title="Equation 3.10">(3.10)</a> is given by switching to the variables \(x_i = \braket{w,\alpha_i}-1\text{,}\) resulting in the system</p>
<div class="displaymath">
\begin{equation}
Ax=d,\quad x\geq 0\text{,}\label{eq-pos-linprog-normal-form}\tag{3.13}
\end{equation}
</div>
<p class="continuation">where the matrix \(A\) is the matrix whose rows are \(e_i+e_j-e_k\in\mathbb{Z}^N\) for each linear relation \(\alpha_i+\alpha_j=\alpha_k\) (dropping linearly dependent conditions) and the right-hand-side vector is \(d=(-1,\ldots,-1)\text{.}\)</p>
<p id="p-111">The non-zero components of the basic feasible solutions of the normal form system <a class="xref" data-knowl="./knowl/eq-pos-linprog-normal-form.html" title="Equation 3.13">(3.13)</a> are determined by \(B^{-1}d\) where \(B\) is some invertible square submatrix of \(A\text{.}\) Writing</p>
<div class="displaymath">
\begin{equation*}
B^{-1} = \frac{1}{\det B}\operatorname{Adj}(B)\text{,}
\end{equation*}
</div>
<p class="continuation">where \(\operatorname{Adj}(B)\) is the adjugate matrix of \(B\text{,}\) we see that integer solutions are determined by the vectors \(\operatorname{Adj}(B)d\text{.}\) Since each row of \(A\) has the norm bound \(\norm{e_i+e_j-e_k}_\infty\leq 2\) every minor of \(A\) is bounded by \(2^N\text{.}\) Hence we can bound the norms of integer basic feasible solutions to <a class="xref" data-knowl="./knowl/eq-pos-linprog-normal-form.html" title="Equation 3.13">(3.13)</a> by</p>
<div class="displaymath">
\begin{equation*}
\norm{x}_\infty = \norm{\operatorname{Adj}(B)d}_\infty \leq N2^N\text{.}
\end{equation*}
</div>
<p class="continuation">Consequently the original problem <a class="xref" data-knowl="./knowl/eq-positive.html" title="Equation 3.10">(3.10)</a> has a solution \(w\in\mathbb{Z}^k\) if and only if there exists a solution \(w\) with</p>
<div class="displaymath">
\begin{equation*}
\abs{\braket{w,\alpha_i}} = \abs{x_i+1} \leq 1+N2^N\text{.}
\end{equation*}
</div>
<p id="p-112">Finally, if \(w\in\mathbb{Z}^k\) is as above, we claim that \(\tilde{w} = M^{k}w + (1,M,\ldots,M^{k-1})\) is a solution to <a class="xref" data-knowl="./knowl/eq-positive.html" title="Equation 3.10">(3.10)</a>–<a class="xref" data-knowl="./knowl/eq-bounded-abs-diff.html" title="Equation 3.12">(3.12)</a>.</p>
<p id="p-113">To see that \(\tilde{w}\) satisfies <a class="xref" data-knowl="./knowl/eq-positive.html" title="Equation 3.10">(3.10)</a>–<a class="xref" data-knowl="./knowl/eq-bounded-abs-diff.html" title="Equation 3.12">(3.12)</a>, we consider base-\(M\) expansions of the integers \(\braket{\tilde{w},\alpha_i}\) and \(\braket{\tilde{w},\alpha_i-\alpha_j}\text{.}\) Since \(\norm{\alpha_i}_\infty\lt M\text{,}\) we have</p>
<div class="displaymath">
\begin{equation*}
\braket{\tilde{w},\alpha_i} = M^{k}\braket{w,\alpha_i} + \sum_{j=1}^{k}M^{j-1}\braket{e_j,\alpha_i}\geq M^{k} - \sum_{j=1}^{k}M^{j-1}\norm{\alpha_i}_\infty\geq 1.
\end{equation*}
</div>
<p class="continuation">A similar computation using \(\norm{\alpha_i-\alpha_j}_\infty\lt M\) gives the bound</p>
<div class="displaymath">
\begin{align*}
\abs{\braket{\tilde{w},\alpha_i-\alpha_j}} \amp\leq M^{k}\abs{\braket{w,\alpha_i}}+M^{k}\abs{\braket{w,\alpha_j}} + \sum_{j=1}^{k}M^{j-1}\norm{\alpha_i-\alpha_j}_\infty\\
\amp\leq (2+N2^{N+1})M^{k} + M^{k}=C\text{,}
\end{align*}
</div>
<p class="continuation">showing <a class="xref" data-knowl="./knowl/eq-bounded-abs-diff.html" title="Equation 3.12">(3.12)</a> so it remains to verify <a class="xref" data-knowl="./knowl/eq-disjoint.html" title="Equation 3.11">(3.11)</a>. Expanding in terms of powers of \(M\text{,}\) we have</p>
<div class="displaymath">
\begin{equation*}
\braket{\tilde{w},\alpha_i-\alpha_j}  = \sum_{h=1}^{k}M^{h-1}\braket{e_h,\alpha_i-\alpha_j} \quad\mod{M^k}\text{.}
\end{equation*}
</div>
<p class="continuation">Since \(\abs{\braket{e_h,\alpha_i-\alpha_j}}\leq \norm{\alpha_i-\alpha_j}_\infty\lt M\) it follows that \(\braket{\tilde{w},\alpha_i-\alpha_j}\neq 0\) as soon as at least one \(\braket{e_h,\alpha_i-\alpha_j}\neq 0\text{.}\) Since \(\alpha_i\neq \alpha_j\text{,}\) this latter condition is always satisfied for some \(h\text{.}\)</p></article></div>
<article class="remark remark-like" id="rmk-lightweight-positivity-algorithm"><h6 class="heading">
<span class="type">Remark</span><span class="space"> </span><span class="codenumber">3.10</span><span class="period">.</span>
</h6>
<p id="p-114">To obtain any positive realization, there is a much simpler polynomial time algorithm: Solve the linear programming problem</p>
<div class="displaymath">
\begin{equation*}
\braket{w,\alpha_i}\geq 1,\quad i=1,\ldots,N
\end{equation*}
</div>
<p class="continuation">in the rational variables \(w\in\mathbb{Q}^k\) and rescale and perturb the solution to</p>
<div class="displaymath">
\begin{equation*}
\tilde{w} = M^kw + (1,M,\ldots,M^{k-1})
\end{equation*}
</div>
<p class="continuation">as in the proof of correctness to guarantee distinct weights. Then the push-forward grading by \(f(\tilde{w},\cdot)\colon \mathbb{Z}^k\to\mathbb{Q}\) is again a positive realization of the original grading, but the resulting weights may be quite large.</p></article></section><section class="subsection" id="section-maximal-construction"><h3 class="heading hide-type">
<span class="type">Subsection</span> <span class="codenumber">3.4</span> <span class="title">Maximal gradings</span>
</h3>
<p id="p-115">In this section we provide an algorithm to construct a maximal grading for a Lie algebra \(\mathfrak{g}\) defined over an algebraically closed field \(F\text{.}\)</p>
<article class="algorithm theorem-like" id="algorithm-maximal-grading"><h6 class="heading">
<span class="type">Algorithm</span><span class="space"> </span><span class="codenumber">3.11</span><span class="period">.</span><span class="space"> </span><span class="title">Maximal grading.</span>
</h6>
<p id="p-116">Input: A Lie algebra \(\mathfrak{g}\) defined over an algebraically closed field \(F\text{.}\) Output: A <a class="xref" data-knowl="./knowl/def-maximal-grading.html" title="Definition 2.17">maximal grading</a> of \(\mathfrak{g}\text{.}\)</p>
<ol class="decimal">
<li id="maxalg-1-derivations">Compute  the derivation algebra \(\der(\mathfrak{g})\text{.}\) Set \(B=\emptyset\text{.}\)</li>
<li id="maxalg-2-centralizer">Compute a basis \(A_1,\ldots,A_n\) for the centralizer \(C(B)\subset \der(\mathfrak{g})\text{.}\)</li>
<li id="maxalg-3-extension">Repeat for each basis element \(A_i\text{,}\) \(i=1,\ldots,n\text{:}\) compute the Jordan decomposition \(A_i=S_i+N_i\text{.}\) If the semisimple part \(S_i\) is not in the linear span of \(B\text{,}\) extend \(B\) by \(S_i\) and go back to step <a class="xref" data-knowl="./knowl/maxalg-2-centralizer.html" title="Item 2">2</a>.</li>
<li id="maxalg-4-eigenspace-grading">Determine the \(\mathfrak{t}^*\)-grading \(\mathcal{V}:\mathfrak{g}=\bigoplus_\lambda V_\lambda\) <a class="xref" data-knowl="./knowl/def-grading-induced-by-torus.html" title="Definition 2.14">induced by the torus</a> \(\mathfrak{t}=\langle B\rangle\text{.}\)</li>
<li id="maxalg-5-zk-indexing">Compute and return the <a class="xref" data-knowl="./knowl/def-universal-realization.html" title="Definition 2.8">universal realization</a> of the grading \(\mathcal{V}\text{.}\)</li>
</ol></article><article class="remark remark-like" id="remark-maximal-grading-field-extension"><h6 class="heading">
<span class="type">Remark</span><span class="space"> </span><span class="codenumber">3.12</span><span class="period">.</span>
</h6>
<p id="p-117">If the Lie algebra \(\mathfrak{g}\) is <a class="xref" data-knowl="./knowl/def-defined-over.html" title="Definition 2.1">defined over</a> a field \(F\text{,}\) then \(\der(\mathfrak{g})\) has a maximal torus defined over \(F\text{.}\) Hence the base field of \(\mathfrak{g}\) does not play a role in <a class="xref" data-knowl="./knowl/algorithm-maximal-grading.html" title="Algorithm 3.11: Maximal grading">Algorithm 3.11</a>.</p></article><p id="p-118">The rest of the section is devoted to proving the correctness of <a class="xref" data-knowl="./knowl/algorithm-maximal-grading.html" title="Algorithm 3.11: Maximal grading">Algorithm 3.11</a> and to explaining the steps in more detail.</p>
<p id="p-119">Steps <a class="xref" data-knowl="./knowl/maxalg-1-derivations.html" title="Item 1">1</a> and <a class="xref" data-knowl="./knowl/maxalg-2-centralizer.html" title="Item 2">2</a> are straightforward linear algebra. Step <a class="xref" data-knowl="./knowl/maxalg-3-extension.html" title="Item 3">3</a> is the core of the algorithm, where the basis \(B\) is extended until the spanned torus is maximal. Directly by construction each additional element \(S_i\in\der(\mathfrak{g})\) is a semisimple derivation that commutes with all the previous elements of \(B\text{,}\) so \(B\) always spans a torus. The nontrivial part is that this construction guarantees that the resulting torus \(\mathfrak{t}\) spanned by \(B\) is maximal. This is guaranteed by the following lemma.</p>
<article class="lemma theorem-like" id="lemma-torus-extension"><h6 class="heading">
<span class="type">Lemma</span><span class="space"> </span><span class="codenumber">3.13</span><span class="period">.</span>
</h6>
<p id="p-120">Let \(\mathfrak{g}\) be a Lie algebra defined over an algebraically closed field \(F\text{.}\) Let \(\mathfrak{t}\subset\der(\mathfrak{g})\) be a torus and let \(A_1,\ldots,A_n\) be a basis of the centralizer \(C(\mathfrak{t})\subset \der(\mathfrak{g})\text{.}\) Let \(A_i = S_i+N_i\) be the Jordan decompositions of each basis element. If \(S_i\in\mathfrak{t}\) for all \(i=1,\ldots,n\text{,}\) then there do not exist any semisimple derivations in \(C(\mathfrak{t})\setminus\mathfrak{t}\text{.}\)</p></article><article class="hiddenproof" id="proof-11"><a data-knowl="" class="id-ref proof-knowl original" data-refid="hk-proof-11"><h6 class="heading"><span class="type">Proof<span class="period">.</span></span></h6></a></article><div class="hidden-content tex2jax_ignore" id="hk-proof-11"><article class="hiddenproof"><p id="p-121">First we claim that if \(S_i\in\mathfrak{t}\) for all \(i=1,\ldots,n\text{,}\) then the centralizer \(C(\mathfrak{t})\) is a nilpotent Lie algebra. By Engel's theorem the centralizer is nilpotent if and only if each map \(\ad(A_i)\colon C(\mathfrak{t})\to C(\mathfrak{t})\) is nilpotent. By definition \(\mathfrak{t}\) is central in \(C(\mathfrak{t})\text{,}\) so we have</p>
<div class="displaymath">
\begin{equation*}
\ad(A_i)=\ad(S_i)+\ad(N_i) = \ad(N_i)\text{.}
\end{equation*}
</div>
<p class="continuation">Since each \(N_i\in\der(\mathfrak{g})\) is nilpotent, so is \(\ad(N_i)\) and the claim follows.</p>
<p id="p-122">Next, we claim that the Jordan decomposition of a sum of basis elements is</p>
<div class="displaymath">
\begin{equation}
A_i+A_j = (S_i+S_j) + (N_i+N_j)\text{.}\label{eq-jordan-decomp-of-sum}\tag{3.14}
\end{equation}
</div>
<p class="continuation">By assumption \(S_i,S_j\in\mathfrak{t}\text{,}\) so also \(S_i+S_j\in\mathfrak{t}\) and hence the sum \(S_i+S_j\) is semisimple. Moreover since \(\mathfrak{t}\) is central, \([S_i+S_j,N_i+N_j]=0\text{,}\) so all that remains is to show that \(N_i+N_j\) is nilpotent.</p>
<p id="p-123">Since the centralizer \(C(\mathfrak{t})\) is nilpotent, it is also solvable. Since the field \(F\) is an algebraically closed field of characteristic zero, Lie's theorem implies that there exists a basis of \(\mathfrak{g}\) such that all the derivations \(A_i\) are represented by upper triangular matrices. Then \(N_i\) and \(N_j\) are both strictly upper triangular matrices, so also the sum \(N_i+N_j\) is strictly upper triangular, and hence nilpotent.</p>
<p id="p-124">The Jordan decompositions <a class="xref" data-knowl="./knowl/eq-jordan-decomp-of-sum.html" title="Equation 3.14">(3.14)</a> and the assumption that \(S_i\in\mathfrak{t}\) for all \(i=1,\ldots,n\) imply that the semisimple part of every linear combination of the elements \(A_i\) is also contained in \(\mathfrak{t}\text{.}\) Hence there cannot exist any semisimple elements in \(C(\mathfrak{t})\setminus\mathfrak{t}\text{.}\)</p></article></div>
<article class="remark remark-like" id="remark-jordan-decompositions"><h6 class="heading">
<span class="type">Remark</span><span class="space"> </span><span class="codenumber">3.14</span><span class="period">.</span>
</h6>
<p id="p-125">The Jordan decompositions required in Step <a class="xref" data-knowl="./knowl/maxalg-3-extension.html" title="Item 3">3</a> of <a class="xref" data-knowl="./knowl/algorithm-maximal-grading.html" title="Algorithm 3.11: Maximal grading">Algorithm 3.11</a> can be efficiently computed using the algorithm given in Appendix A.2 of <a class="xref" data-knowl="./knowl/deGraaf-2000-Lie_algebras_theory_and_algorithms.html" title="Bibliographic Entry 11: Lie algebras: theory and algorithms">[11]</a>.</p></article><p id="p-126">In step <a class="xref" data-knowl="./knowl/maxalg-4-eigenspace-grading.html" title="Item 4">4</a>, the grading induced by the torus \(\mathfrak{t}\) has a concrete description in terms of the fixed basis \(B\) of \(\mathfrak{t}\text{.}\) Namely, the basis \(\delta_1,\ldots,\delta_k\) defines an isomorphism \(\mathfrak{t}^*\to F^k\) and hence an <a class="xref" data-knowl="./knowl/def-equivalent-group-gradings.html" title="Definition 2.5">equivalent</a> <a class="xref" data-knowl="./knowl/def-push-forward-grading.html" title="Definition 2.4">push-forward grading</a> over \(F^k\text{.}\) Expanding out the construction of <a class="xref" data-knowl="./knowl/lemma-gradings-induced.html" title="Lemma 2.13">Lemma 2.13</a> shows that the push-forward grading has the <a class="xref" data-knowl="./knowl/def-grading.html" title="Definition 2.2">layers</a></p>
<div class="displaymath">
\begin{equation*}
V_\lambda = V_{(\lambda_1,\ldots,\lambda_k)}
= \bigcap_{i=1}^k E^{\lambda_i}_{\delta_i}\text{,}
\end{equation*}
</div>
<p class="continuation">where \(E^{\lambda_i}_{\delta_i}\) is the (possibly zero) eigenspace for the eigenvalue \(\lambda_i\) of the derivation \(\delta_i\text{.}\)</p>
<p id="p-127">The final part of <a class="xref" data-knowl="./knowl/algorithm-maximal-grading.html" title="Algorithm 3.11: Maximal grading">Algorithm 3.11</a> is step <a class="xref" data-knowl="./knowl/maxalg-5-zk-indexing.html" title="Item 5">5</a>, where we replace the indexing by eigenvalues of the derivations of \(\mathfrak{t}\) with indexing over some \(\mathbb{Z}^k\) given by the universal realization. The precise method was described earlier in <a class="xref" data-knowl="./knowl/algorithm-integer-vector-grading.html" title="Algorithm 2.9: Universal realization">Algorithm 2.9</a>. Since the construction of the first three steps of <a class="xref" data-knowl="./knowl/algorithm-maximal-grading.html" title="Algorithm 3.11: Maximal grading">Algorithm 3.11</a> leads to a maximal torus of \(\der(\mathfrak{g})\text{,}\) by <a class="xref" data-knowl="./knowl/def-maximal-grading.html" title="Definition 2.17">Definition 2.17</a> the output is a maximal grading of \(\mathfrak{g}\text{.}\)</p>
<article class="remark remark-like" id="remark-non-algebraically-closed-fields"><h6 class="heading">
<span class="type">Remark</span><span class="space"> </span><span class="codenumber">3.15</span><span class="period">.</span>
</h6>
<p id="p-128">The relevance of the assumption that the field \(F\) is algebraically closed is to guarantee that the constructed tori are split, i.e., the semisimple derivations are diagonalizable. The Jordan decomposition and <a class="xref" data-knowl="./knowl/lemma-torus-extension.html" title="Lemma 3.13">Lemma 3.13</a> then give us an efficient method to construct diagonalizable derivations in \(C(\mathfrak{t})\setminus\mathfrak{t}\text{.}\)</p>
<p id="p-129">If the base field is not algebraically closed, finding diagonalizable elements of \(C(\mathfrak{t})\setminus\mathfrak{t}\) is more difficult. The subset of diagonalizable elements is a semialgebraic set in \(\mathfrak{gl}(\mathfrak{g})\text{,}\) and constructions to extract points from such sets exist, see for instance Section 13 of <a class="xref" data-knowl="./knowl/Basu-Pollack-Roy-2006-algorithms-in-real-algebraic-geometry.html" title="Bibliographic Entry 1: Algorithms in real algebraic geometry">[1]</a> on the existential theory of the reals. The problem is that these methods are practical only in low dimensions, whereas \(\dim\mathfrak{gl}(\mathfrak{g})=\dim(\mathfrak{g})^2\text{.}\) For Lie algebras defined over finite fields, more efficient randomized algorithms to find split tori exist, see <a class="xref" data-knowl="./knowl/Cohen-Murray-2009_algorith_for_langs_theorem.html" title="Bibliographic Entry 5: An algorithm for Lang's Theorem">[5]</a> and <a class="xref" data-knowl="./knowl/Roozemond-2013-split_maximal_tori.html" title="Bibliographic Entry 29: Computing split maximal toral subalgebras of Lie algebras over fields of small characteristic">[29]</a>.</p>
<p id="p-130">Nonetheless, even when the Lie algebra \(\mathfrak{g}\) is defined over a non-algebraically closed field \(F\text{,}\) it is possible that the computation of a maximal grading over the algebraic closure \(\bar{F}\) using <a class="xref" data-knowl="./knowl/algorithm-maximal-grading.html" title="Algorithm 3.11: Maximal grading">Algorithm 3.11</a> outputs a grading that is still defined over \(F\text{.}\) Then the output is also a maximal grading of the Lie algebra \(\mathfrak{g}\) over \(F\text{.}\) This happens for example with the Lie algebra \(L_{6,19}(-1)\) over \(\mathbb{Q}\text{,}\) but not with the Lie algebra \(L_{6,19}(1)\text{,}\) where the maximal torus over the rationals is 2-dimensional, but the maximal torus over the algebraic numbers is 3-dimensional.</p></article></section></section></div></main>
</div>
</body>
</html>
